/*
 * Kubernetes
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v1.11.1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package io.kubernetes.client.models;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.kubernetes.client.models.V1beta1CustomResourceDefinitionCondition;
import io.kubernetes.client.models.V1beta1CustomResourceDefinitionNames;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

/**
 * CustomResourceDefinitionStatus indicates the state of the CustomResourceDefinition
 */
@ApiModel(description = "CustomResourceDefinitionStatus indicates the state of the CustomResourceDefinition")

public class V1beta1CustomResourceDefinitionStatus {
  @SerializedName("acceptedNames")
  private V1beta1CustomResourceDefinitionNames acceptedNames = null;

  @SerializedName("conditions")
  private List<V1beta1CustomResourceDefinitionCondition> conditions = new ArrayList<V1beta1CustomResourceDefinitionCondition>();

  @SerializedName("storedVersions")
  private List<String> storedVersions = new ArrayList<String>();

  public V1beta1CustomResourceDefinitionStatus acceptedNames(V1beta1CustomResourceDefinitionNames acceptedNames) {
    this.acceptedNames = acceptedNames;
    return this;
  }

   /**
   * AcceptedNames are the names that are actually being used to serve discovery They may be different than the names in spec.
   * @return acceptedNames
  **/
  @ApiModelProperty(required = true, value = "AcceptedNames are the names that are actually being used to serve discovery They may be different than the names in spec.")
  public V1beta1CustomResourceDefinitionNames getAcceptedNames() {
    return acceptedNames;
  }

  public void setAcceptedNames(V1beta1CustomResourceDefinitionNames acceptedNames) {
    this.acceptedNames = acceptedNames;
  }

  public V1beta1CustomResourceDefinitionStatus conditions(List<V1beta1CustomResourceDefinitionCondition> conditions) {
    this.conditions = conditions;
    return this;
  }

  public V1beta1CustomResourceDefinitionStatus addConditionsItem(V1beta1CustomResourceDefinitionCondition conditionsItem) {
    this.conditions.add(conditionsItem);
    return this;
  }

   /**
   * Conditions indicate state for particular aspects of a CustomResourceDefinition
   * @return conditions
  **/
  @ApiModelProperty(required = true, value = "Conditions indicate state for particular aspects of a CustomResourceDefinition")
  public List<V1beta1CustomResourceDefinitionCondition> getConditions() {
    return conditions;
  }

  public void setConditions(List<V1beta1CustomResourceDefinitionCondition> conditions) {
    this.conditions = conditions;
  }

  public V1beta1CustomResourceDefinitionStatus storedVersions(List<String> storedVersions) {
    this.storedVersions = storedVersions;
    return this;
  }

  public V1beta1CustomResourceDefinitionStatus addStoredVersionsItem(String storedVersionsItem) {
    this.storedVersions.add(storedVersionsItem);
    return this;
  }

   /**
   * StoredVersions are all versions of CustomResources that were ever persisted. Tracking these versions allows a migration path for stored versions in etcd. The field is mutable so the migration controller can first finish a migration to another version (i.e. that no old objects are left in the storage), and then remove the rest of the versions from this list. None of the versions in this list can be removed from the spec.Versions field.
   * @return storedVersions
  **/
  @ApiModelProperty(required = true, value = "StoredVersions are all versions of CustomResources that were ever persisted. Tracking these versions allows a migration path for stored versions in etcd. The field is mutable so the migration controller can first finish a migration to another version (i.e. that no old objects are left in the storage), and then remove the rest of the versions from this list. None of the versions in this list can be removed from the spec.Versions field.")
  public List<String> getStoredVersions() {
    return storedVersions;
  }

  public void setStoredVersions(List<String> storedVersions) {
    this.storedVersions = storedVersions;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    V1beta1CustomResourceDefinitionStatus v1beta1CustomResourceDefinitionStatus = (V1beta1CustomResourceDefinitionStatus) o;
    return Objects.equals(this.acceptedNames, v1beta1CustomResourceDefinitionStatus.acceptedNames) &&
        Objects.equals(this.conditions, v1beta1CustomResourceDefinitionStatus.conditions) &&
        Objects.equals(this.storedVersions, v1beta1CustomResourceDefinitionStatus.storedVersions);
  }

  @Override
  public int hashCode() {
    return Objects.hash(acceptedNames, conditions, storedVersions);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class V1beta1CustomResourceDefinitionStatus {\n");
    
    sb.append("    acceptedNames: ").append(toIndentedString(acceptedNames)).append("\n");
    sb.append("    conditions: ").append(toIndentedString(conditions)).append("\n");
    sb.append("    storedVersions: ").append(toIndentedString(storedVersions)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

