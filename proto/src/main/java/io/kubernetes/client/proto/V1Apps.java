// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: k8s.io/api/apps/v1/generated.proto

package io.kubernetes.client.proto;

public final class V1Apps {
  private V1Apps() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }

  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
    registerAllExtensions(
        (com.google.protobuf.ExtensionRegistryLite) registry);
  }
  public interface DaemonSetOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.apps.v1.DaemonSet)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    boolean hasMetadata();
    /**
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ObjectMeta getMetadata();
    /**
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder();

    /**
     * <pre>
     * The desired behavior of this daemon set.
     * More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.DaemonSetSpec spec = 2;</code>
     */
    boolean hasSpec();
    /**
     * <pre>
     * The desired behavior of this daemon set.
     * More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.DaemonSetSpec spec = 2;</code>
     */
    io.kubernetes.client.proto.V1Apps.DaemonSetSpec getSpec();
    /**
     * <pre>
     * The desired behavior of this daemon set.
     * More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.DaemonSetSpec spec = 2;</code>
     */
    io.kubernetes.client.proto.V1Apps.DaemonSetSpecOrBuilder getSpecOrBuilder();

    /**
     * <pre>
     * The current status of this daemon set. This data may be
     * out of date by some window of time.
     * Populated by the system.
     * Read-only.
     * More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.DaemonSetStatus status = 3;</code>
     */
    boolean hasStatus();
    /**
     * <pre>
     * The current status of this daemon set. This data may be
     * out of date by some window of time.
     * Populated by the system.
     * Read-only.
     * More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.DaemonSetStatus status = 3;</code>
     */
    io.kubernetes.client.proto.V1Apps.DaemonSetStatus getStatus();
    /**
     * <pre>
     * The current status of this daemon set. This data may be
     * out of date by some window of time.
     * Populated by the system.
     * Read-only.
     * More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.DaemonSetStatus status = 3;</code>
     */
    io.kubernetes.client.proto.V1Apps.DaemonSetStatusOrBuilder getStatusOrBuilder();
  }
  /**
   * <pre>
   * DaemonSet represents the configuration of a daemon set.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.apps.v1.DaemonSet}
   */
  public  static final class DaemonSet extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.apps.v1.DaemonSet)
      DaemonSetOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use DaemonSet.newBuilder() to construct.
    private DaemonSet(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private DaemonSet() {
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private DaemonSet(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              io.kubernetes.client.proto.Meta.ObjectMeta.Builder subBuilder = null;
              if (((bitField0_ & 0x00000001) == 0x00000001)) {
                subBuilder = metadata_.toBuilder();
              }
              metadata_ = input.readMessage(io.kubernetes.client.proto.Meta.ObjectMeta.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(metadata_);
                metadata_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000001;
              break;
            }
            case 18: {
              io.kubernetes.client.proto.V1Apps.DaemonSetSpec.Builder subBuilder = null;
              if (((bitField0_ & 0x00000002) == 0x00000002)) {
                subBuilder = spec_.toBuilder();
              }
              spec_ = input.readMessage(io.kubernetes.client.proto.V1Apps.DaemonSetSpec.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(spec_);
                spec_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000002;
              break;
            }
            case 26: {
              io.kubernetes.client.proto.V1Apps.DaemonSetStatus.Builder subBuilder = null;
              if (((bitField0_ & 0x00000004) == 0x00000004)) {
                subBuilder = status_.toBuilder();
              }
              status_ = input.readMessage(io.kubernetes.client.proto.V1Apps.DaemonSetStatus.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(status_);
                status_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000004;
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DaemonSet_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DaemonSet_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Apps.DaemonSet.class, io.kubernetes.client.proto.V1Apps.DaemonSet.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ObjectMeta metadata_;
    /**
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
    }
    /**
     * <pre>
     * Standard object's metadata.
     * More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
    }

    public static final int SPEC_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.V1Apps.DaemonSetSpec spec_;
    /**
     * <pre>
     * The desired behavior of this daemon set.
     * More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.DaemonSetSpec spec = 2;</code>
     */
    public boolean hasSpec() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * The desired behavior of this daemon set.
     * More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.DaemonSetSpec spec = 2;</code>
     */
    public io.kubernetes.client.proto.V1Apps.DaemonSetSpec getSpec() {
      return spec_ == null ? io.kubernetes.client.proto.V1Apps.DaemonSetSpec.getDefaultInstance() : spec_;
    }
    /**
     * <pre>
     * The desired behavior of this daemon set.
     * More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.DaemonSetSpec spec = 2;</code>
     */
    public io.kubernetes.client.proto.V1Apps.DaemonSetSpecOrBuilder getSpecOrBuilder() {
      return spec_ == null ? io.kubernetes.client.proto.V1Apps.DaemonSetSpec.getDefaultInstance() : spec_;
    }

    public static final int STATUS_FIELD_NUMBER = 3;
    private io.kubernetes.client.proto.V1Apps.DaemonSetStatus status_;
    /**
     * <pre>
     * The current status of this daemon set. This data may be
     * out of date by some window of time.
     * Populated by the system.
     * Read-only.
     * More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.DaemonSetStatus status = 3;</code>
     */
    public boolean hasStatus() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <pre>
     * The current status of this daemon set. This data may be
     * out of date by some window of time.
     * Populated by the system.
     * Read-only.
     * More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.DaemonSetStatus status = 3;</code>
     */
    public io.kubernetes.client.proto.V1Apps.DaemonSetStatus getStatus() {
      return status_ == null ? io.kubernetes.client.proto.V1Apps.DaemonSetStatus.getDefaultInstance() : status_;
    }
    /**
     * <pre>
     * The current status of this daemon set. This data may be
     * out of date by some window of time.
     * Populated by the system.
     * Read-only.
     * More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.DaemonSetStatus status = 3;</code>
     */
    public io.kubernetes.client.proto.V1Apps.DaemonSetStatusOrBuilder getStatusOrBuilder() {
      return status_ == null ? io.kubernetes.client.proto.V1Apps.DaemonSetStatus.getDefaultInstance() : status_;
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeMessage(1, getMetadata());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeMessage(2, getSpec());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeMessage(3, getStatus());
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getMetadata());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getSpec());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getStatus());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Apps.DaemonSet)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Apps.DaemonSet other = (io.kubernetes.client.proto.V1Apps.DaemonSet) obj;

      boolean result = true;
      result = result && (hasMetadata() == other.hasMetadata());
      if (hasMetadata()) {
        result = result && getMetadata()
            .equals(other.getMetadata());
      }
      result = result && (hasSpec() == other.hasSpec());
      if (hasSpec()) {
        result = result && getSpec()
            .equals(other.getSpec());
      }
      result = result && (hasStatus() == other.hasStatus());
      if (hasStatus()) {
        result = result && getStatus()
            .equals(other.getStatus());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (hasSpec()) {
        hash = (37 * hash) + SPEC_FIELD_NUMBER;
        hash = (53 * hash) + getSpec().hashCode();
      }
      if (hasStatus()) {
        hash = (37 * hash) + STATUS_FIELD_NUMBER;
        hash = (53 * hash) + getStatus().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Apps.DaemonSet parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSet parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSet parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSet parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSet parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSet parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSet parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSet parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSet parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSet parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSet parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSet parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Apps.DaemonSet prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * DaemonSet represents the configuration of a daemon set.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.apps.v1.DaemonSet}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.apps.v1.DaemonSet)
        io.kubernetes.client.proto.V1Apps.DaemonSetOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DaemonSet_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DaemonSet_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Apps.DaemonSet.class, io.kubernetes.client.proto.V1Apps.DaemonSet.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Apps.DaemonSet.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getSpecFieldBuilder();
          getStatusFieldBuilder();
        }
      }
      public Builder clear() {
        super.clear();
        if (metadataBuilder_ == null) {
          metadata_ = null;
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        if (specBuilder_ == null) {
          spec_ = null;
        } else {
          specBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        if (statusBuilder_ == null) {
          status_ = null;
        } else {
          statusBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DaemonSet_descriptor;
      }

      public io.kubernetes.client.proto.V1Apps.DaemonSet getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Apps.DaemonSet.getDefaultInstance();
      }

      public io.kubernetes.client.proto.V1Apps.DaemonSet build() {
        io.kubernetes.client.proto.V1Apps.DaemonSet result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public io.kubernetes.client.proto.V1Apps.DaemonSet buildPartial() {
        io.kubernetes.client.proto.V1Apps.DaemonSet result = new io.kubernetes.client.proto.V1Apps.DaemonSet(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        if (metadataBuilder_ == null) {
          result.metadata_ = metadata_;
        } else {
          result.metadata_ = metadataBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        if (specBuilder_ == null) {
          result.spec_ = spec_;
        } else {
          result.spec_ = specBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
          to_bitField0_ |= 0x00000004;
        }
        if (statusBuilder_ == null) {
          result.status_ = status_;
        } else {
          result.status_ = statusBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Apps.DaemonSet) {
          return mergeFrom((io.kubernetes.client.proto.V1Apps.DaemonSet)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Apps.DaemonSet other) {
        if (other == io.kubernetes.client.proto.V1Apps.DaemonSet.getDefaultInstance()) return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (other.hasSpec()) {
          mergeSpec(other.getSpec());
        }
        if (other.hasStatus()) {
          mergeStatus(other.getStatus());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1Apps.DaemonSet parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1Apps.DaemonSet) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ObjectMeta metadata_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder> metadataBuilder_;
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null ? io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
          onChanged();
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder setMetadata(
          io.kubernetes.client.proto.Meta.ObjectMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
          onChanged();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ObjectMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001) &&
              metadata_ != null &&
              metadata_ != io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance()) {
            metadata_ =
              io.kubernetes.client.proto.Meta.ObjectMeta.newBuilder(metadata_).mergeFrom(value).buildPartial();
          } else {
            metadata_ = value;
          }
          onChanged();
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        if (metadataBuilder_ == null) {
          metadata_ = null;
          onChanged();
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null ?
              io.kubernetes.client.proto.Meta.ObjectMeta.getDefaultInstance() : metadata_;
        }
      }
      /**
       * <pre>
       * Standard object's metadata.
       * More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder> 
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.ObjectMeta, io.kubernetes.client.proto.Meta.ObjectMeta.Builder, io.kubernetes.client.proto.Meta.ObjectMetaOrBuilder>(
                  getMetadata(),
                  getParentForChildren(),
                  isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private io.kubernetes.client.proto.V1Apps.DaemonSetSpec spec_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1Apps.DaemonSetSpec, io.kubernetes.client.proto.V1Apps.DaemonSetSpec.Builder, io.kubernetes.client.proto.V1Apps.DaemonSetSpecOrBuilder> specBuilder_;
      /**
       * <pre>
       * The desired behavior of this daemon set.
       * More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DaemonSetSpec spec = 2;</code>
       */
      public boolean hasSpec() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <pre>
       * The desired behavior of this daemon set.
       * More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DaemonSetSpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1Apps.DaemonSetSpec getSpec() {
        if (specBuilder_ == null) {
          return spec_ == null ? io.kubernetes.client.proto.V1Apps.DaemonSetSpec.getDefaultInstance() : spec_;
        } else {
          return specBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * The desired behavior of this daemon set.
       * More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DaemonSetSpec spec = 2;</code>
       */
      public Builder setSpec(io.kubernetes.client.proto.V1Apps.DaemonSetSpec value) {
        if (specBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          spec_ = value;
          onChanged();
        } else {
          specBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * The desired behavior of this daemon set.
       * More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DaemonSetSpec spec = 2;</code>
       */
      public Builder setSpec(
          io.kubernetes.client.proto.V1Apps.DaemonSetSpec.Builder builderForValue) {
        if (specBuilder_ == null) {
          spec_ = builderForValue.build();
          onChanged();
        } else {
          specBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * The desired behavior of this daemon set.
       * More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DaemonSetSpec spec = 2;</code>
       */
      public Builder mergeSpec(io.kubernetes.client.proto.V1Apps.DaemonSetSpec value) {
        if (specBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002) &&
              spec_ != null &&
              spec_ != io.kubernetes.client.proto.V1Apps.DaemonSetSpec.getDefaultInstance()) {
            spec_ =
              io.kubernetes.client.proto.V1Apps.DaemonSetSpec.newBuilder(spec_).mergeFrom(value).buildPartial();
          } else {
            spec_ = value;
          }
          onChanged();
        } else {
          specBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * The desired behavior of this daemon set.
       * More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DaemonSetSpec spec = 2;</code>
       */
      public Builder clearSpec() {
        if (specBuilder_ == null) {
          spec_ = null;
          onChanged();
        } else {
          specBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }
      /**
       * <pre>
       * The desired behavior of this daemon set.
       * More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DaemonSetSpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1Apps.DaemonSetSpec.Builder getSpecBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getSpecFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The desired behavior of this daemon set.
       * More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DaemonSetSpec spec = 2;</code>
       */
      public io.kubernetes.client.proto.V1Apps.DaemonSetSpecOrBuilder getSpecOrBuilder() {
        if (specBuilder_ != null) {
          return specBuilder_.getMessageOrBuilder();
        } else {
          return spec_ == null ?
              io.kubernetes.client.proto.V1Apps.DaemonSetSpec.getDefaultInstance() : spec_;
        }
      }
      /**
       * <pre>
       * The desired behavior of this daemon set.
       * More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DaemonSetSpec spec = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1Apps.DaemonSetSpec, io.kubernetes.client.proto.V1Apps.DaemonSetSpec.Builder, io.kubernetes.client.proto.V1Apps.DaemonSetSpecOrBuilder> 
          getSpecFieldBuilder() {
        if (specBuilder_ == null) {
          specBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1Apps.DaemonSetSpec, io.kubernetes.client.proto.V1Apps.DaemonSetSpec.Builder, io.kubernetes.client.proto.V1Apps.DaemonSetSpecOrBuilder>(
                  getSpec(),
                  getParentForChildren(),
                  isClean());
          spec_ = null;
        }
        return specBuilder_;
      }

      private io.kubernetes.client.proto.V1Apps.DaemonSetStatus status_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1Apps.DaemonSetStatus, io.kubernetes.client.proto.V1Apps.DaemonSetStatus.Builder, io.kubernetes.client.proto.V1Apps.DaemonSetStatusOrBuilder> statusBuilder_;
      /**
       * <pre>
       * The current status of this daemon set. This data may be
       * out of date by some window of time.
       * Populated by the system.
       * Read-only.
       * More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DaemonSetStatus status = 3;</code>
       */
      public boolean hasStatus() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       * <pre>
       * The current status of this daemon set. This data may be
       * out of date by some window of time.
       * Populated by the system.
       * Read-only.
       * More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DaemonSetStatus status = 3;</code>
       */
      public io.kubernetes.client.proto.V1Apps.DaemonSetStatus getStatus() {
        if (statusBuilder_ == null) {
          return status_ == null ? io.kubernetes.client.proto.V1Apps.DaemonSetStatus.getDefaultInstance() : status_;
        } else {
          return statusBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * The current status of this daemon set. This data may be
       * out of date by some window of time.
       * Populated by the system.
       * Read-only.
       * More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DaemonSetStatus status = 3;</code>
       */
      public Builder setStatus(io.kubernetes.client.proto.V1Apps.DaemonSetStatus value) {
        if (statusBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          status_ = value;
          onChanged();
        } else {
          statusBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <pre>
       * The current status of this daemon set. This data may be
       * out of date by some window of time.
       * Populated by the system.
       * Read-only.
       * More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DaemonSetStatus status = 3;</code>
       */
      public Builder setStatus(
          io.kubernetes.client.proto.V1Apps.DaemonSetStatus.Builder builderForValue) {
        if (statusBuilder_ == null) {
          status_ = builderForValue.build();
          onChanged();
        } else {
          statusBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <pre>
       * The current status of this daemon set. This data may be
       * out of date by some window of time.
       * Populated by the system.
       * Read-only.
       * More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DaemonSetStatus status = 3;</code>
       */
      public Builder mergeStatus(io.kubernetes.client.proto.V1Apps.DaemonSetStatus value) {
        if (statusBuilder_ == null) {
          if (((bitField0_ & 0x00000004) == 0x00000004) &&
              status_ != null &&
              status_ != io.kubernetes.client.proto.V1Apps.DaemonSetStatus.getDefaultInstance()) {
            status_ =
              io.kubernetes.client.proto.V1Apps.DaemonSetStatus.newBuilder(status_).mergeFrom(value).buildPartial();
          } else {
            status_ = value;
          }
          onChanged();
        } else {
          statusBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <pre>
       * The current status of this daemon set. This data may be
       * out of date by some window of time.
       * Populated by the system.
       * Read-only.
       * More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DaemonSetStatus status = 3;</code>
       */
      public Builder clearStatus() {
        if (statusBuilder_ == null) {
          status_ = null;
          onChanged();
        } else {
          statusBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }
      /**
       * <pre>
       * The current status of this daemon set. This data may be
       * out of date by some window of time.
       * Populated by the system.
       * Read-only.
       * More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DaemonSetStatus status = 3;</code>
       */
      public io.kubernetes.client.proto.V1Apps.DaemonSetStatus.Builder getStatusBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getStatusFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The current status of this daemon set. This data may be
       * out of date by some window of time.
       * Populated by the system.
       * Read-only.
       * More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DaemonSetStatus status = 3;</code>
       */
      public io.kubernetes.client.proto.V1Apps.DaemonSetStatusOrBuilder getStatusOrBuilder() {
        if (statusBuilder_ != null) {
          return statusBuilder_.getMessageOrBuilder();
        } else {
          return status_ == null ?
              io.kubernetes.client.proto.V1Apps.DaemonSetStatus.getDefaultInstance() : status_;
        }
      }
      /**
       * <pre>
       * The current status of this daemon set. This data may be
       * out of date by some window of time.
       * Populated by the system.
       * Read-only.
       * More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#spec-and-status
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DaemonSetStatus status = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1Apps.DaemonSetStatus, io.kubernetes.client.proto.V1Apps.DaemonSetStatus.Builder, io.kubernetes.client.proto.V1Apps.DaemonSetStatusOrBuilder> 
          getStatusFieldBuilder() {
        if (statusBuilder_ == null) {
          statusBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1Apps.DaemonSetStatus, io.kubernetes.client.proto.V1Apps.DaemonSetStatus.Builder, io.kubernetes.client.proto.V1Apps.DaemonSetStatusOrBuilder>(
                  getStatus(),
                  getParentForChildren(),
                  isClean());
          status_ = null;
        }
        return statusBuilder_;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.apps.v1.DaemonSet)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.apps.v1.DaemonSet)
    private static final io.kubernetes.client.proto.V1Apps.DaemonSet DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Apps.DaemonSet();
    }

    public static io.kubernetes.client.proto.V1Apps.DaemonSet getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<DaemonSet>
        PARSER = new com.google.protobuf.AbstractParser<DaemonSet>() {
      public DaemonSet parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
          return new DaemonSet(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<DaemonSet> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<DaemonSet> getParserForType() {
      return PARSER;
    }

    public io.kubernetes.client.proto.V1Apps.DaemonSet getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface DaemonSetListOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.apps.v1.DaemonSetList)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    boolean hasMetadata();
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ListMeta getMetadata();
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder();

    /**
     * <pre>
     * A list of daemon sets.
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.DaemonSet items = 2;</code>
     */
    java.util.List<io.kubernetes.client.proto.V1Apps.DaemonSet> 
        getItemsList();
    /**
     * <pre>
     * A list of daemon sets.
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.DaemonSet items = 2;</code>
     */
    io.kubernetes.client.proto.V1Apps.DaemonSet getItems(int index);
    /**
     * <pre>
     * A list of daemon sets.
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.DaemonSet items = 2;</code>
     */
    int getItemsCount();
    /**
     * <pre>
     * A list of daemon sets.
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.DaemonSet items = 2;</code>
     */
    java.util.List<? extends io.kubernetes.client.proto.V1Apps.DaemonSetOrBuilder> 
        getItemsOrBuilderList();
    /**
     * <pre>
     * A list of daemon sets.
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.DaemonSet items = 2;</code>
     */
    io.kubernetes.client.proto.V1Apps.DaemonSetOrBuilder getItemsOrBuilder(
        int index);
  }
  /**
   * <pre>
   * DaemonSetList is a collection of daemon sets.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.apps.v1.DaemonSetList}
   */
  public  static final class DaemonSetList extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.apps.v1.DaemonSetList)
      DaemonSetListOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use DaemonSetList.newBuilder() to construct.
    private DaemonSetList(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private DaemonSetList() {
      items_ = java.util.Collections.emptyList();
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private DaemonSetList(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              io.kubernetes.client.proto.Meta.ListMeta.Builder subBuilder = null;
              if (((bitField0_ & 0x00000001) == 0x00000001)) {
                subBuilder = metadata_.toBuilder();
              }
              metadata_ = input.readMessage(io.kubernetes.client.proto.Meta.ListMeta.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(metadata_);
                metadata_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000001;
              break;
            }
            case 18: {
              if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
                items_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Apps.DaemonSet>();
                mutable_bitField0_ |= 0x00000002;
              }
              items_.add(
                  input.readMessage(io.kubernetes.client.proto.V1Apps.DaemonSet.PARSER, extensionRegistry));
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
          items_ = java.util.Collections.unmodifiableList(items_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DaemonSetList_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DaemonSetList_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Apps.DaemonSetList.class, io.kubernetes.client.proto.V1Apps.DaemonSetList.Builder.class);
    }

    private int bitField0_;
    public static final int METADATA_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.ListMeta metadata_;
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    public boolean hasMetadata() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
    }
    /**
     * <pre>
     * Standard list metadata.
     * More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
      return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
    }

    public static final int ITEMS_FIELD_NUMBER = 2;
    private java.util.List<io.kubernetes.client.proto.V1Apps.DaemonSet> items_;
    /**
     * <pre>
     * A list of daemon sets.
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.DaemonSet items = 2;</code>
     */
    public java.util.List<io.kubernetes.client.proto.V1Apps.DaemonSet> getItemsList() {
      return items_;
    }
    /**
     * <pre>
     * A list of daemon sets.
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.DaemonSet items = 2;</code>
     */
    public java.util.List<? extends io.kubernetes.client.proto.V1Apps.DaemonSetOrBuilder> 
        getItemsOrBuilderList() {
      return items_;
    }
    /**
     * <pre>
     * A list of daemon sets.
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.DaemonSet items = 2;</code>
     */
    public int getItemsCount() {
      return items_.size();
    }
    /**
     * <pre>
     * A list of daemon sets.
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.DaemonSet items = 2;</code>
     */
    public io.kubernetes.client.proto.V1Apps.DaemonSet getItems(int index) {
      return items_.get(index);
    }
    /**
     * <pre>
     * A list of daemon sets.
     * </pre>
     *
     * <code>repeated .k8s.io.api.apps.v1.DaemonSet items = 2;</code>
     */
    public io.kubernetes.client.proto.V1Apps.DaemonSetOrBuilder getItemsOrBuilder(
        int index) {
      return items_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeMessage(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        output.writeMessage(2, items_.get(i));
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getMetadata());
      }
      for (int i = 0; i < items_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, items_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Apps.DaemonSetList)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Apps.DaemonSetList other = (io.kubernetes.client.proto.V1Apps.DaemonSetList) obj;

      boolean result = true;
      result = result && (hasMetadata() == other.hasMetadata());
      if (hasMetadata()) {
        result = result && getMetadata()
            .equals(other.getMetadata());
      }
      result = result && getItemsList()
          .equals(other.getItemsList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMetadata()) {
        hash = (37 * hash) + METADATA_FIELD_NUMBER;
        hash = (53 * hash) + getMetadata().hashCode();
      }
      if (getItemsCount() > 0) {
        hash = (37 * hash) + ITEMS_FIELD_NUMBER;
        hash = (53 * hash) + getItemsList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Apps.DaemonSetList parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetList parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetList parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetList parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetList parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetList parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetList parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetList parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetList parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetList parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetList parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetList parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Apps.DaemonSetList prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * DaemonSetList is a collection of daemon sets.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.apps.v1.DaemonSetList}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.apps.v1.DaemonSetList)
        io.kubernetes.client.proto.V1Apps.DaemonSetListOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DaemonSetList_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DaemonSetList_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Apps.DaemonSetList.class, io.kubernetes.client.proto.V1Apps.DaemonSetList.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Apps.DaemonSetList.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getMetadataFieldBuilder();
          getItemsFieldBuilder();
        }
      }
      public Builder clear() {
        super.clear();
        if (metadataBuilder_ == null) {
          metadata_ = null;
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
        } else {
          itemsBuilder_.clear();
        }
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DaemonSetList_descriptor;
      }

      public io.kubernetes.client.proto.V1Apps.DaemonSetList getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Apps.DaemonSetList.getDefaultInstance();
      }

      public io.kubernetes.client.proto.V1Apps.DaemonSetList build() {
        io.kubernetes.client.proto.V1Apps.DaemonSetList result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public io.kubernetes.client.proto.V1Apps.DaemonSetList buildPartial() {
        io.kubernetes.client.proto.V1Apps.DaemonSetList result = new io.kubernetes.client.proto.V1Apps.DaemonSetList(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        if (metadataBuilder_ == null) {
          result.metadata_ = metadata_;
        } else {
          result.metadata_ = metadataBuilder_.build();
        }
        if (itemsBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002)) {
            items_ = java.util.Collections.unmodifiableList(items_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.items_ = items_;
        } else {
          result.items_ = itemsBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Apps.DaemonSetList) {
          return mergeFrom((io.kubernetes.client.proto.V1Apps.DaemonSetList)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Apps.DaemonSetList other) {
        if (other == io.kubernetes.client.proto.V1Apps.DaemonSetList.getDefaultInstance()) return this;
        if (other.hasMetadata()) {
          mergeMetadata(other.getMetadata());
        }
        if (itemsBuilder_ == null) {
          if (!other.items_.isEmpty()) {
            if (items_.isEmpty()) {
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureItemsIsMutable();
              items_.addAll(other.items_);
            }
            onChanged();
          }
        } else {
          if (!other.items_.isEmpty()) {
            if (itemsBuilder_.isEmpty()) {
              itemsBuilder_.dispose();
              itemsBuilder_ = null;
              items_ = other.items_;
              bitField0_ = (bitField0_ & ~0x00000002);
              itemsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getItemsFieldBuilder() : null;
            } else {
              itemsBuilder_.addAllMessages(other.items_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1Apps.DaemonSetList parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1Apps.DaemonSetList) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.Meta.ListMeta metadata_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder> metadataBuilder_;
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public boolean hasMetadata() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMeta getMetadata() {
        if (metadataBuilder_ == null) {
          return metadata_ == null ? io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
        } else {
          return metadataBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          metadata_ = value;
          onChanged();
        } else {
          metadataBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder setMetadata(
          io.kubernetes.client.proto.Meta.ListMeta.Builder builderForValue) {
        if (metadataBuilder_ == null) {
          metadata_ = builderForValue.build();
          onChanged();
        } else {
          metadataBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder mergeMetadata(io.kubernetes.client.proto.Meta.ListMeta value) {
        if (metadataBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001) &&
              metadata_ != null &&
              metadata_ != io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance()) {
            metadata_ =
              io.kubernetes.client.proto.Meta.ListMeta.newBuilder(metadata_).mergeFrom(value).buildPartial();
          } else {
            metadata_ = value;
          }
          onChanged();
        } else {
          metadataBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public Builder clearMetadata() {
        if (metadataBuilder_ == null) {
          metadata_ = null;
          onChanged();
        } else {
          metadataBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMeta.Builder getMetadataBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMetadataFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.ListMetaOrBuilder getMetadataOrBuilder() {
        if (metadataBuilder_ != null) {
          return metadataBuilder_.getMessageOrBuilder();
        } else {
          return metadata_ == null ?
              io.kubernetes.client.proto.Meta.ListMeta.getDefaultInstance() : metadata_;
        }
      }
      /**
       * <pre>
       * Standard list metadata.
       * More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#metadata
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder> 
          getMetadataFieldBuilder() {
        if (metadataBuilder_ == null) {
          metadataBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.ListMeta, io.kubernetes.client.proto.Meta.ListMeta.Builder, io.kubernetes.client.proto.Meta.ListMetaOrBuilder>(
                  getMetadata(),
                  getParentForChildren(),
                  isClean());
          metadata_ = null;
        }
        return metadataBuilder_;
      }

      private java.util.List<io.kubernetes.client.proto.V1Apps.DaemonSet> items_ =
        java.util.Collections.emptyList();
      private void ensureItemsIsMutable() {
        if (!((bitField0_ & 0x00000002) == 0x00000002)) {
          items_ = new java.util.ArrayList<io.kubernetes.client.proto.V1Apps.DaemonSet>(items_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1Apps.DaemonSet, io.kubernetes.client.proto.V1Apps.DaemonSet.Builder, io.kubernetes.client.proto.V1Apps.DaemonSetOrBuilder> itemsBuilder_;

      /**
       * <pre>
       * A list of daemon sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DaemonSet items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Apps.DaemonSet> getItemsList() {
        if (itemsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(items_);
        } else {
          return itemsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * A list of daemon sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DaemonSet items = 2;</code>
       */
      public int getItemsCount() {
        if (itemsBuilder_ == null) {
          return items_.size();
        } else {
          return itemsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * A list of daemon sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DaemonSet items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Apps.DaemonSet getItems(int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);
        } else {
          return itemsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * A list of daemon sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DaemonSet items = 2;</code>
       */
      public Builder setItems(
          int index, io.kubernetes.client.proto.V1Apps.DaemonSet value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.set(index, value);
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * A list of daemon sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DaemonSet items = 2;</code>
       */
      public Builder setItems(
          int index, io.kubernetes.client.proto.V1Apps.DaemonSet.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.set(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * A list of daemon sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DaemonSet items = 2;</code>
       */
      public Builder addItems(io.kubernetes.client.proto.V1Apps.DaemonSet value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * A list of daemon sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DaemonSet items = 2;</code>
       */
      public Builder addItems(
          int index, io.kubernetes.client.proto.V1Apps.DaemonSet value) {
        if (itemsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureItemsIsMutable();
          items_.add(index, value);
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * A list of daemon sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DaemonSet items = 2;</code>
       */
      public Builder addItems(
          io.kubernetes.client.proto.V1Apps.DaemonSet.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * A list of daemon sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DaemonSet items = 2;</code>
       */
      public Builder addItems(
          int index, io.kubernetes.client.proto.V1Apps.DaemonSet.Builder builderForValue) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.add(index, builderForValue.build());
          onChanged();
        } else {
          itemsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * A list of daemon sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DaemonSet items = 2;</code>
       */
      public Builder addAllItems(
          java.lang.Iterable<? extends io.kubernetes.client.proto.V1Apps.DaemonSet> values) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, items_);
          onChanged();
        } else {
          itemsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * A list of daemon sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DaemonSet items = 2;</code>
       */
      public Builder clearItems() {
        if (itemsBuilder_ == null) {
          items_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          itemsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * A list of daemon sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DaemonSet items = 2;</code>
       */
      public Builder removeItems(int index) {
        if (itemsBuilder_ == null) {
          ensureItemsIsMutable();
          items_.remove(index);
          onChanged();
        } else {
          itemsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * A list of daemon sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DaemonSet items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Apps.DaemonSet.Builder getItemsBuilder(
          int index) {
        return getItemsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * A list of daemon sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DaemonSet items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Apps.DaemonSetOrBuilder getItemsOrBuilder(
          int index) {
        if (itemsBuilder_ == null) {
          return items_.get(index);  } else {
          return itemsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * A list of daemon sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DaemonSet items = 2;</code>
       */
      public java.util.List<? extends io.kubernetes.client.proto.V1Apps.DaemonSetOrBuilder> 
           getItemsOrBuilderList() {
        if (itemsBuilder_ != null) {
          return itemsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(items_);
        }
      }
      /**
       * <pre>
       * A list of daemon sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DaemonSet items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Apps.DaemonSet.Builder addItemsBuilder() {
        return getItemsFieldBuilder().addBuilder(
            io.kubernetes.client.proto.V1Apps.DaemonSet.getDefaultInstance());
      }
      /**
       * <pre>
       * A list of daemon sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DaemonSet items = 2;</code>
       */
      public io.kubernetes.client.proto.V1Apps.DaemonSet.Builder addItemsBuilder(
          int index) {
        return getItemsFieldBuilder().addBuilder(
            index, io.kubernetes.client.proto.V1Apps.DaemonSet.getDefaultInstance());
      }
      /**
       * <pre>
       * A list of daemon sets.
       * </pre>
       *
       * <code>repeated .k8s.io.api.apps.v1.DaemonSet items = 2;</code>
       */
      public java.util.List<io.kubernetes.client.proto.V1Apps.DaemonSet.Builder> 
           getItemsBuilderList() {
        return getItemsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          io.kubernetes.client.proto.V1Apps.DaemonSet, io.kubernetes.client.proto.V1Apps.DaemonSet.Builder, io.kubernetes.client.proto.V1Apps.DaemonSetOrBuilder> 
          getItemsFieldBuilder() {
        if (itemsBuilder_ == null) {
          itemsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              io.kubernetes.client.proto.V1Apps.DaemonSet, io.kubernetes.client.proto.V1Apps.DaemonSet.Builder, io.kubernetes.client.proto.V1Apps.DaemonSetOrBuilder>(
                  items_,
                  ((bitField0_ & 0x00000002) == 0x00000002),
                  getParentForChildren(),
                  isClean());
          items_ = null;
        }
        return itemsBuilder_;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.apps.v1.DaemonSetList)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.apps.v1.DaemonSetList)
    private static final io.kubernetes.client.proto.V1Apps.DaemonSetList DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Apps.DaemonSetList();
    }

    public static io.kubernetes.client.proto.V1Apps.DaemonSetList getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<DaemonSetList>
        PARSER = new com.google.protobuf.AbstractParser<DaemonSetList>() {
      public DaemonSetList parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
          return new DaemonSetList(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<DaemonSetList> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<DaemonSetList> getParserForType() {
      return PARSER;
    }

    public io.kubernetes.client.proto.V1Apps.DaemonSetList getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface DaemonSetSpecOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.apps.v1.DaemonSetSpec)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * A label query over pods that are managed by the daemon set.
     * Must match in order to be controlled.
     * If empty, defaulted to labels on Pod template.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 1;</code>
     */
    boolean hasSelector();
    /**
     * <pre>
     * A label query over pods that are managed by the daemon set.
     * Must match in order to be controlled.
     * If empty, defaulted to labels on Pod template.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 1;</code>
     */
    io.kubernetes.client.proto.Meta.LabelSelector getSelector();
    /**
     * <pre>
     * A label query over pods that are managed by the daemon set.
     * Must match in order to be controlled.
     * If empty, defaulted to labels on Pod template.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 1;</code>
     */
    io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getSelectorOrBuilder();

    /**
     * <pre>
     * An object that describes the pod that will be created.
     * The DaemonSet will create exactly one copy of this pod on every node
     * that matches the template's node selector (or on every node if no node
     * selector is specified).
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 2;</code>
     */
    boolean hasTemplate();
    /**
     * <pre>
     * An object that describes the pod that will be created.
     * The DaemonSet will create exactly one copy of this pod on every node
     * that matches the template's node selector (or on every node if no node
     * selector is specified).
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 2;</code>
     */
    io.kubernetes.client.proto.V1.PodTemplateSpec getTemplate();
    /**
     * <pre>
     * An object that describes the pod that will be created.
     * The DaemonSet will create exactly one copy of this pod on every node
     * that matches the template's node selector (or on every node if no node
     * selector is specified).
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 2;</code>
     */
    io.kubernetes.client.proto.V1.PodTemplateSpecOrBuilder getTemplateOrBuilder();

    /**
     * <pre>
     * An update strategy to replace existing DaemonSet pods with new pods.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.DaemonSetUpdateStrategy updateStrategy = 3;</code>
     */
    boolean hasUpdateStrategy();
    /**
     * <pre>
     * An update strategy to replace existing DaemonSet pods with new pods.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.DaemonSetUpdateStrategy updateStrategy = 3;</code>
     */
    io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy getUpdateStrategy();
    /**
     * <pre>
     * An update strategy to replace existing DaemonSet pods with new pods.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.DaemonSetUpdateStrategy updateStrategy = 3;</code>
     */
    io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategyOrBuilder getUpdateStrategyOrBuilder();

    /**
     * <pre>
     * The minimum number of seconds for which a newly created DaemonSet pod should
     * be ready without any of its container crashing, for it to be considered
     * available. Defaults to 0 (pod will be considered available as soon as it
     * is ready).
     * +optional
     * </pre>
     *
     * <code>optional int32 minReadySeconds = 4;</code>
     */
    boolean hasMinReadySeconds();
    /**
     * <pre>
     * The minimum number of seconds for which a newly created DaemonSet pod should
     * be ready without any of its container crashing, for it to be considered
     * available. Defaults to 0 (pod will be considered available as soon as it
     * is ready).
     * +optional
     * </pre>
     *
     * <code>optional int32 minReadySeconds = 4;</code>
     */
    int getMinReadySeconds();

    /**
     * <pre>
     * The number of old history to retain to allow rollback.
     * This is a pointer to distinguish between explicit zero and not specified.
     * Defaults to 10.
     * +optional
     * </pre>
     *
     * <code>optional int32 revisionHistoryLimit = 6;</code>
     */
    boolean hasRevisionHistoryLimit();
    /**
     * <pre>
     * The number of old history to retain to allow rollback.
     * This is a pointer to distinguish between explicit zero and not specified.
     * Defaults to 10.
     * +optional
     * </pre>
     *
     * <code>optional int32 revisionHistoryLimit = 6;</code>
     */
    int getRevisionHistoryLimit();
  }
  /**
   * <pre>
   * DaemonSetSpec is the specification of a daemon set.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.apps.v1.DaemonSetSpec}
   */
  public  static final class DaemonSetSpec extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.apps.v1.DaemonSetSpec)
      DaemonSetSpecOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use DaemonSetSpec.newBuilder() to construct.
    private DaemonSetSpec(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private DaemonSetSpec() {
      minReadySeconds_ = 0;
      revisionHistoryLimit_ = 0;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private DaemonSetSpec(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              io.kubernetes.client.proto.Meta.LabelSelector.Builder subBuilder = null;
              if (((bitField0_ & 0x00000001) == 0x00000001)) {
                subBuilder = selector_.toBuilder();
              }
              selector_ = input.readMessage(io.kubernetes.client.proto.Meta.LabelSelector.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(selector_);
                selector_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000001;
              break;
            }
            case 18: {
              io.kubernetes.client.proto.V1.PodTemplateSpec.Builder subBuilder = null;
              if (((bitField0_ & 0x00000002) == 0x00000002)) {
                subBuilder = template_.toBuilder();
              }
              template_ = input.readMessage(io.kubernetes.client.proto.V1.PodTemplateSpec.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(template_);
                template_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000002;
              break;
            }
            case 26: {
              io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy.Builder subBuilder = null;
              if (((bitField0_ & 0x00000004) == 0x00000004)) {
                subBuilder = updateStrategy_.toBuilder();
              }
              updateStrategy_ = input.readMessage(io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(updateStrategy_);
                updateStrategy_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000004;
              break;
            }
            case 32: {
              bitField0_ |= 0x00000008;
              minReadySeconds_ = input.readInt32();
              break;
            }
            case 48: {
              bitField0_ |= 0x00000010;
              revisionHistoryLimit_ = input.readInt32();
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DaemonSetSpec_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DaemonSetSpec_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Apps.DaemonSetSpec.class, io.kubernetes.client.proto.V1Apps.DaemonSetSpec.Builder.class);
    }

    private int bitField0_;
    public static final int SELECTOR_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.Meta.LabelSelector selector_;
    /**
     * <pre>
     * A label query over pods that are managed by the daemon set.
     * Must match in order to be controlled.
     * If empty, defaulted to labels on Pod template.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 1;</code>
     */
    public boolean hasSelector() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * A label query over pods that are managed by the daemon set.
     * Must match in order to be controlled.
     * If empty, defaulted to labels on Pod template.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.LabelSelector getSelector() {
      return selector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : selector_;
    }
    /**
     * <pre>
     * A label query over pods that are managed by the daemon set.
     * Must match in order to be controlled.
     * If empty, defaulted to labels on Pod template.
     * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 1;</code>
     */
    public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getSelectorOrBuilder() {
      return selector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : selector_;
    }

    public static final int TEMPLATE_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.V1.PodTemplateSpec template_;
    /**
     * <pre>
     * An object that describes the pod that will be created.
     * The DaemonSet will create exactly one copy of this pod on every node
     * that matches the template's node selector (or on every node if no node
     * selector is specified).
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 2;</code>
     */
    public boolean hasTemplate() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * An object that describes the pod that will be created.
     * The DaemonSet will create exactly one copy of this pod on every node
     * that matches the template's node selector (or on every node if no node
     * selector is specified).
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 2;</code>
     */
    public io.kubernetes.client.proto.V1.PodTemplateSpec getTemplate() {
      return template_ == null ? io.kubernetes.client.proto.V1.PodTemplateSpec.getDefaultInstance() : template_;
    }
    /**
     * <pre>
     * An object that describes the pod that will be created.
     * The DaemonSet will create exactly one copy of this pod on every node
     * that matches the template's node selector (or on every node if no node
     * selector is specified).
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
     * </pre>
     *
     * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 2;</code>
     */
    public io.kubernetes.client.proto.V1.PodTemplateSpecOrBuilder getTemplateOrBuilder() {
      return template_ == null ? io.kubernetes.client.proto.V1.PodTemplateSpec.getDefaultInstance() : template_;
    }

    public static final int UPDATESTRATEGY_FIELD_NUMBER = 3;
    private io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy updateStrategy_;
    /**
     * <pre>
     * An update strategy to replace existing DaemonSet pods with new pods.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.DaemonSetUpdateStrategy updateStrategy = 3;</code>
     */
    public boolean hasUpdateStrategy() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <pre>
     * An update strategy to replace existing DaemonSet pods with new pods.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.DaemonSetUpdateStrategy updateStrategy = 3;</code>
     */
    public io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy getUpdateStrategy() {
      return updateStrategy_ == null ? io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy.getDefaultInstance() : updateStrategy_;
    }
    /**
     * <pre>
     * An update strategy to replace existing DaemonSet pods with new pods.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.DaemonSetUpdateStrategy updateStrategy = 3;</code>
     */
    public io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategyOrBuilder getUpdateStrategyOrBuilder() {
      return updateStrategy_ == null ? io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy.getDefaultInstance() : updateStrategy_;
    }

    public static final int MINREADYSECONDS_FIELD_NUMBER = 4;
    private int minReadySeconds_;
    /**
     * <pre>
     * The minimum number of seconds for which a newly created DaemonSet pod should
     * be ready without any of its container crashing, for it to be considered
     * available. Defaults to 0 (pod will be considered available as soon as it
     * is ready).
     * +optional
     * </pre>
     *
     * <code>optional int32 minReadySeconds = 4;</code>
     */
    public boolean hasMinReadySeconds() {
      return ((bitField0_ & 0x00000008) == 0x00000008);
    }
    /**
     * <pre>
     * The minimum number of seconds for which a newly created DaemonSet pod should
     * be ready without any of its container crashing, for it to be considered
     * available. Defaults to 0 (pod will be considered available as soon as it
     * is ready).
     * +optional
     * </pre>
     *
     * <code>optional int32 minReadySeconds = 4;</code>
     */
    public int getMinReadySeconds() {
      return minReadySeconds_;
    }

    public static final int REVISIONHISTORYLIMIT_FIELD_NUMBER = 6;
    private int revisionHistoryLimit_;
    /**
     * <pre>
     * The number of old history to retain to allow rollback.
     * This is a pointer to distinguish between explicit zero and not specified.
     * Defaults to 10.
     * +optional
     * </pre>
     *
     * <code>optional int32 revisionHistoryLimit = 6;</code>
     */
    public boolean hasRevisionHistoryLimit() {
      return ((bitField0_ & 0x00000010) == 0x00000010);
    }
    /**
     * <pre>
     * The number of old history to retain to allow rollback.
     * This is a pointer to distinguish between explicit zero and not specified.
     * Defaults to 10.
     * +optional
     * </pre>
     *
     * <code>optional int32 revisionHistoryLimit = 6;</code>
     */
    public int getRevisionHistoryLimit() {
      return revisionHistoryLimit_;
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeMessage(1, getSelector());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeMessage(2, getTemplate());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeMessage(3, getUpdateStrategy());
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        output.writeInt32(4, minReadySeconds_);
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        output.writeInt32(6, revisionHistoryLimit_);
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getSelector());
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getTemplate());
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getUpdateStrategy());
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(4, minReadySeconds_);
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(6, revisionHistoryLimit_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Apps.DaemonSetSpec)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Apps.DaemonSetSpec other = (io.kubernetes.client.proto.V1Apps.DaemonSetSpec) obj;

      boolean result = true;
      result = result && (hasSelector() == other.hasSelector());
      if (hasSelector()) {
        result = result && getSelector()
            .equals(other.getSelector());
      }
      result = result && (hasTemplate() == other.hasTemplate());
      if (hasTemplate()) {
        result = result && getTemplate()
            .equals(other.getTemplate());
      }
      result = result && (hasUpdateStrategy() == other.hasUpdateStrategy());
      if (hasUpdateStrategy()) {
        result = result && getUpdateStrategy()
            .equals(other.getUpdateStrategy());
      }
      result = result && (hasMinReadySeconds() == other.hasMinReadySeconds());
      if (hasMinReadySeconds()) {
        result = result && (getMinReadySeconds()
            == other.getMinReadySeconds());
      }
      result = result && (hasRevisionHistoryLimit() == other.hasRevisionHistoryLimit());
      if (hasRevisionHistoryLimit()) {
        result = result && (getRevisionHistoryLimit()
            == other.getRevisionHistoryLimit());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasSelector()) {
        hash = (37 * hash) + SELECTOR_FIELD_NUMBER;
        hash = (53 * hash) + getSelector().hashCode();
      }
      if (hasTemplate()) {
        hash = (37 * hash) + TEMPLATE_FIELD_NUMBER;
        hash = (53 * hash) + getTemplate().hashCode();
      }
      if (hasUpdateStrategy()) {
        hash = (37 * hash) + UPDATESTRATEGY_FIELD_NUMBER;
        hash = (53 * hash) + getUpdateStrategy().hashCode();
      }
      if (hasMinReadySeconds()) {
        hash = (37 * hash) + MINREADYSECONDS_FIELD_NUMBER;
        hash = (53 * hash) + getMinReadySeconds();
      }
      if (hasRevisionHistoryLimit()) {
        hash = (37 * hash) + REVISIONHISTORYLIMIT_FIELD_NUMBER;
        hash = (53 * hash) + getRevisionHistoryLimit();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Apps.DaemonSetSpec parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetSpec parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetSpec parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetSpec parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetSpec parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetSpec parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetSpec parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetSpec parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetSpec parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetSpec parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetSpec parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetSpec parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Apps.DaemonSetSpec prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * DaemonSetSpec is the specification of a daemon set.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.apps.v1.DaemonSetSpec}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.apps.v1.DaemonSetSpec)
        io.kubernetes.client.proto.V1Apps.DaemonSetSpecOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DaemonSetSpec_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DaemonSetSpec_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Apps.DaemonSetSpec.class, io.kubernetes.client.proto.V1Apps.DaemonSetSpec.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Apps.DaemonSetSpec.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getSelectorFieldBuilder();
          getTemplateFieldBuilder();
          getUpdateStrategyFieldBuilder();
        }
      }
      public Builder clear() {
        super.clear();
        if (selectorBuilder_ == null) {
          selector_ = null;
        } else {
          selectorBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        if (templateBuilder_ == null) {
          template_ = null;
        } else {
          templateBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        if (updateStrategyBuilder_ == null) {
          updateStrategy_ = null;
        } else {
          updateStrategyBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        minReadySeconds_ = 0;
        bitField0_ = (bitField0_ & ~0x00000008);
        revisionHistoryLimit_ = 0;
        bitField0_ = (bitField0_ & ~0x00000010);
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DaemonSetSpec_descriptor;
      }

      public io.kubernetes.client.proto.V1Apps.DaemonSetSpec getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Apps.DaemonSetSpec.getDefaultInstance();
      }

      public io.kubernetes.client.proto.V1Apps.DaemonSetSpec build() {
        io.kubernetes.client.proto.V1Apps.DaemonSetSpec result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public io.kubernetes.client.proto.V1Apps.DaemonSetSpec buildPartial() {
        io.kubernetes.client.proto.V1Apps.DaemonSetSpec result = new io.kubernetes.client.proto.V1Apps.DaemonSetSpec(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        if (selectorBuilder_ == null) {
          result.selector_ = selector_;
        } else {
          result.selector_ = selectorBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        if (templateBuilder_ == null) {
          result.template_ = template_;
        } else {
          result.template_ = templateBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
          to_bitField0_ |= 0x00000004;
        }
        if (updateStrategyBuilder_ == null) {
          result.updateStrategy_ = updateStrategy_;
        } else {
          result.updateStrategy_ = updateStrategyBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
          to_bitField0_ |= 0x00000008;
        }
        result.minReadySeconds_ = minReadySeconds_;
        if (((from_bitField0_ & 0x00000010) == 0x00000010)) {
          to_bitField0_ |= 0x00000010;
        }
        result.revisionHistoryLimit_ = revisionHistoryLimit_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Apps.DaemonSetSpec) {
          return mergeFrom((io.kubernetes.client.proto.V1Apps.DaemonSetSpec)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Apps.DaemonSetSpec other) {
        if (other == io.kubernetes.client.proto.V1Apps.DaemonSetSpec.getDefaultInstance()) return this;
        if (other.hasSelector()) {
          mergeSelector(other.getSelector());
        }
        if (other.hasTemplate()) {
          mergeTemplate(other.getTemplate());
        }
        if (other.hasUpdateStrategy()) {
          mergeUpdateStrategy(other.getUpdateStrategy());
        }
        if (other.hasMinReadySeconds()) {
          setMinReadySeconds(other.getMinReadySeconds());
        }
        if (other.hasRevisionHistoryLimit()) {
          setRevisionHistoryLimit(other.getRevisionHistoryLimit());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1Apps.DaemonSetSpec parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1Apps.DaemonSetSpec) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.Meta.LabelSelector selector_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder> selectorBuilder_;
      /**
       * <pre>
       * A label query over pods that are managed by the daemon set.
       * Must match in order to be controlled.
       * If empty, defaulted to labels on Pod template.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 1;</code>
       */
      public boolean hasSelector() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * A label query over pods that are managed by the daemon set.
       * Must match in order to be controlled.
       * If empty, defaulted to labels on Pod template.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelector getSelector() {
        if (selectorBuilder_ == null) {
          return selector_ == null ? io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : selector_;
        } else {
          return selectorBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * A label query over pods that are managed by the daemon set.
       * Must match in order to be controlled.
       * If empty, defaulted to labels on Pod template.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 1;</code>
       */
      public Builder setSelector(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (selectorBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          selector_ = value;
          onChanged();
        } else {
          selectorBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * A label query over pods that are managed by the daemon set.
       * Must match in order to be controlled.
       * If empty, defaulted to labels on Pod template.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 1;</code>
       */
      public Builder setSelector(
          io.kubernetes.client.proto.Meta.LabelSelector.Builder builderForValue) {
        if (selectorBuilder_ == null) {
          selector_ = builderForValue.build();
          onChanged();
        } else {
          selectorBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * A label query over pods that are managed by the daemon set.
       * Must match in order to be controlled.
       * If empty, defaulted to labels on Pod template.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 1;</code>
       */
      public Builder mergeSelector(io.kubernetes.client.proto.Meta.LabelSelector value) {
        if (selectorBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001) &&
              selector_ != null &&
              selector_ != io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance()) {
            selector_ =
              io.kubernetes.client.proto.Meta.LabelSelector.newBuilder(selector_).mergeFrom(value).buildPartial();
          } else {
            selector_ = value;
          }
          onChanged();
        } else {
          selectorBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * A label query over pods that are managed by the daemon set.
       * Must match in order to be controlled.
       * If empty, defaulted to labels on Pod template.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 1;</code>
       */
      public Builder clearSelector() {
        if (selectorBuilder_ == null) {
          selector_ = null;
          onChanged();
        } else {
          selectorBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }
      /**
       * <pre>
       * A label query over pods that are managed by the daemon set.
       * Must match in order to be controlled.
       * If empty, defaulted to labels on Pod template.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelector.Builder getSelectorBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getSelectorFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * A label query over pods that are managed by the daemon set.
       * Must match in order to be controlled.
       * If empty, defaulted to labels on Pod template.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 1;</code>
       */
      public io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder getSelectorOrBuilder() {
        if (selectorBuilder_ != null) {
          return selectorBuilder_.getMessageOrBuilder();
        } else {
          return selector_ == null ?
              io.kubernetes.client.proto.Meta.LabelSelector.getDefaultInstance() : selector_;
        }
      }
      /**
       * <pre>
       * A label query over pods that are managed by the daemon set.
       * Must match in order to be controlled.
       * If empty, defaulted to labels on Pod template.
       * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder> 
          getSelectorFieldBuilder() {
        if (selectorBuilder_ == null) {
          selectorBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.Meta.LabelSelector, io.kubernetes.client.proto.Meta.LabelSelector.Builder, io.kubernetes.client.proto.Meta.LabelSelectorOrBuilder>(
                  getSelector(),
                  getParentForChildren(),
                  isClean());
          selector_ = null;
        }
        return selectorBuilder_;
      }

      private io.kubernetes.client.proto.V1.PodTemplateSpec template_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1.PodTemplateSpec, io.kubernetes.client.proto.V1.PodTemplateSpec.Builder, io.kubernetes.client.proto.V1.PodTemplateSpecOrBuilder> templateBuilder_;
      /**
       * <pre>
       * An object that describes the pod that will be created.
       * The DaemonSet will create exactly one copy of this pod on every node
       * that matches the template's node selector (or on every node if no node
       * selector is specified).
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 2;</code>
       */
      public boolean hasTemplate() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <pre>
       * An object that describes the pod that will be created.
       * The DaemonSet will create exactly one copy of this pod on every node
       * that matches the template's node selector (or on every node if no node
       * selector is specified).
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 2;</code>
       */
      public io.kubernetes.client.proto.V1.PodTemplateSpec getTemplate() {
        if (templateBuilder_ == null) {
          return template_ == null ? io.kubernetes.client.proto.V1.PodTemplateSpec.getDefaultInstance() : template_;
        } else {
          return templateBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * An object that describes the pod that will be created.
       * The DaemonSet will create exactly one copy of this pod on every node
       * that matches the template's node selector (or on every node if no node
       * selector is specified).
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 2;</code>
       */
      public Builder setTemplate(io.kubernetes.client.proto.V1.PodTemplateSpec value) {
        if (templateBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          template_ = value;
          onChanged();
        } else {
          templateBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * An object that describes the pod that will be created.
       * The DaemonSet will create exactly one copy of this pod on every node
       * that matches the template's node selector (or on every node if no node
       * selector is specified).
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 2;</code>
       */
      public Builder setTemplate(
          io.kubernetes.client.proto.V1.PodTemplateSpec.Builder builderForValue) {
        if (templateBuilder_ == null) {
          template_ = builderForValue.build();
          onChanged();
        } else {
          templateBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * An object that describes the pod that will be created.
       * The DaemonSet will create exactly one copy of this pod on every node
       * that matches the template's node selector (or on every node if no node
       * selector is specified).
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 2;</code>
       */
      public Builder mergeTemplate(io.kubernetes.client.proto.V1.PodTemplateSpec value) {
        if (templateBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002) &&
              template_ != null &&
              template_ != io.kubernetes.client.proto.V1.PodTemplateSpec.getDefaultInstance()) {
            template_ =
              io.kubernetes.client.proto.V1.PodTemplateSpec.newBuilder(template_).mergeFrom(value).buildPartial();
          } else {
            template_ = value;
          }
          onChanged();
        } else {
          templateBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * An object that describes the pod that will be created.
       * The DaemonSet will create exactly one copy of this pod on every node
       * that matches the template's node selector (or on every node if no node
       * selector is specified).
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 2;</code>
       */
      public Builder clearTemplate() {
        if (templateBuilder_ == null) {
          template_ = null;
          onChanged();
        } else {
          templateBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }
      /**
       * <pre>
       * An object that describes the pod that will be created.
       * The DaemonSet will create exactly one copy of this pod on every node
       * that matches the template's node selector (or on every node if no node
       * selector is specified).
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 2;</code>
       */
      public io.kubernetes.client.proto.V1.PodTemplateSpec.Builder getTemplateBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getTemplateFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * An object that describes the pod that will be created.
       * The DaemonSet will create exactly one copy of this pod on every node
       * that matches the template's node selector (or on every node if no node
       * selector is specified).
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 2;</code>
       */
      public io.kubernetes.client.proto.V1.PodTemplateSpecOrBuilder getTemplateOrBuilder() {
        if (templateBuilder_ != null) {
          return templateBuilder_.getMessageOrBuilder();
        } else {
          return template_ == null ?
              io.kubernetes.client.proto.V1.PodTemplateSpec.getDefaultInstance() : template_;
        }
      }
      /**
       * <pre>
       * An object that describes the pod that will be created.
       * The DaemonSet will create exactly one copy of this pod on every node
       * that matches the template's node selector (or on every node if no node
       * selector is specified).
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
       * </pre>
       *
       * <code>optional .k8s.io.api.core.v1.PodTemplateSpec template = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1.PodTemplateSpec, io.kubernetes.client.proto.V1.PodTemplateSpec.Builder, io.kubernetes.client.proto.V1.PodTemplateSpecOrBuilder> 
          getTemplateFieldBuilder() {
        if (templateBuilder_ == null) {
          templateBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1.PodTemplateSpec, io.kubernetes.client.proto.V1.PodTemplateSpec.Builder, io.kubernetes.client.proto.V1.PodTemplateSpecOrBuilder>(
                  getTemplate(),
                  getParentForChildren(),
                  isClean());
          template_ = null;
        }
        return templateBuilder_;
      }

      private io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy updateStrategy_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy, io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy.Builder, io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategyOrBuilder> updateStrategyBuilder_;
      /**
       * <pre>
       * An update strategy to replace existing DaemonSet pods with new pods.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DaemonSetUpdateStrategy updateStrategy = 3;</code>
       */
      public boolean hasUpdateStrategy() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       * <pre>
       * An update strategy to replace existing DaemonSet pods with new pods.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DaemonSetUpdateStrategy updateStrategy = 3;</code>
       */
      public io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy getUpdateStrategy() {
        if (updateStrategyBuilder_ == null) {
          return updateStrategy_ == null ? io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy.getDefaultInstance() : updateStrategy_;
        } else {
          return updateStrategyBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * An update strategy to replace existing DaemonSet pods with new pods.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DaemonSetUpdateStrategy updateStrategy = 3;</code>
       */
      public Builder setUpdateStrategy(io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy value) {
        if (updateStrategyBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          updateStrategy_ = value;
          onChanged();
        } else {
          updateStrategyBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <pre>
       * An update strategy to replace existing DaemonSet pods with new pods.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DaemonSetUpdateStrategy updateStrategy = 3;</code>
       */
      public Builder setUpdateStrategy(
          io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy.Builder builderForValue) {
        if (updateStrategyBuilder_ == null) {
          updateStrategy_ = builderForValue.build();
          onChanged();
        } else {
          updateStrategyBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <pre>
       * An update strategy to replace existing DaemonSet pods with new pods.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DaemonSetUpdateStrategy updateStrategy = 3;</code>
       */
      public Builder mergeUpdateStrategy(io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy value) {
        if (updateStrategyBuilder_ == null) {
          if (((bitField0_ & 0x00000004) == 0x00000004) &&
              updateStrategy_ != null &&
              updateStrategy_ != io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy.getDefaultInstance()) {
            updateStrategy_ =
              io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy.newBuilder(updateStrategy_).mergeFrom(value).buildPartial();
          } else {
            updateStrategy_ = value;
          }
          onChanged();
        } else {
          updateStrategyBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000004;
        return this;
      }
      /**
       * <pre>
       * An update strategy to replace existing DaemonSet pods with new pods.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DaemonSetUpdateStrategy updateStrategy = 3;</code>
       */
      public Builder clearUpdateStrategy() {
        if (updateStrategyBuilder_ == null) {
          updateStrategy_ = null;
          onChanged();
        } else {
          updateStrategyBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }
      /**
       * <pre>
       * An update strategy to replace existing DaemonSet pods with new pods.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DaemonSetUpdateStrategy updateStrategy = 3;</code>
       */
      public io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy.Builder getUpdateStrategyBuilder() {
        bitField0_ |= 0x00000004;
        onChanged();
        return getUpdateStrategyFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * An update strategy to replace existing DaemonSet pods with new pods.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DaemonSetUpdateStrategy updateStrategy = 3;</code>
       */
      public io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategyOrBuilder getUpdateStrategyOrBuilder() {
        if (updateStrategyBuilder_ != null) {
          return updateStrategyBuilder_.getMessageOrBuilder();
        } else {
          return updateStrategy_ == null ?
              io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy.getDefaultInstance() : updateStrategy_;
        }
      }
      /**
       * <pre>
       * An update strategy to replace existing DaemonSet pods with new pods.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.DaemonSetUpdateStrategy updateStrategy = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy, io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy.Builder, io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategyOrBuilder> 
          getUpdateStrategyFieldBuilder() {
        if (updateStrategyBuilder_ == null) {
          updateStrategyBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy, io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy.Builder, io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategyOrBuilder>(
                  getUpdateStrategy(),
                  getParentForChildren(),
                  isClean());
          updateStrategy_ = null;
        }
        return updateStrategyBuilder_;
      }

      private int minReadySeconds_ ;
      /**
       * <pre>
       * The minimum number of seconds for which a newly created DaemonSet pod should
       * be ready without any of its container crashing, for it to be considered
       * available. Defaults to 0 (pod will be considered available as soon as it
       * is ready).
       * +optional
       * </pre>
       *
       * <code>optional int32 minReadySeconds = 4;</code>
       */
      public boolean hasMinReadySeconds() {
        return ((bitField0_ & 0x00000008) == 0x00000008);
      }
      /**
       * <pre>
       * The minimum number of seconds for which a newly created DaemonSet pod should
       * be ready without any of its container crashing, for it to be considered
       * available. Defaults to 0 (pod will be considered available as soon as it
       * is ready).
       * +optional
       * </pre>
       *
       * <code>optional int32 minReadySeconds = 4;</code>
       */
      public int getMinReadySeconds() {
        return minReadySeconds_;
      }
      /**
       * <pre>
       * The minimum number of seconds for which a newly created DaemonSet pod should
       * be ready without any of its container crashing, for it to be considered
       * available. Defaults to 0 (pod will be considered available as soon as it
       * is ready).
       * +optional
       * </pre>
       *
       * <code>optional int32 minReadySeconds = 4;</code>
       */
      public Builder setMinReadySeconds(int value) {
        bitField0_ |= 0x00000008;
        minReadySeconds_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The minimum number of seconds for which a newly created DaemonSet pod should
       * be ready without any of its container crashing, for it to be considered
       * available. Defaults to 0 (pod will be considered available as soon as it
       * is ready).
       * +optional
       * </pre>
       *
       * <code>optional int32 minReadySeconds = 4;</code>
       */
      public Builder clearMinReadySeconds() {
        bitField0_ = (bitField0_ & ~0x00000008);
        minReadySeconds_ = 0;
        onChanged();
        return this;
      }

      private int revisionHistoryLimit_ ;
      /**
       * <pre>
       * The number of old history to retain to allow rollback.
       * This is a pointer to distinguish between explicit zero and not specified.
       * Defaults to 10.
       * +optional
       * </pre>
       *
       * <code>optional int32 revisionHistoryLimit = 6;</code>
       */
      public boolean hasRevisionHistoryLimit() {
        return ((bitField0_ & 0x00000010) == 0x00000010);
      }
      /**
       * <pre>
       * The number of old history to retain to allow rollback.
       * This is a pointer to distinguish between explicit zero and not specified.
       * Defaults to 10.
       * +optional
       * </pre>
       *
       * <code>optional int32 revisionHistoryLimit = 6;</code>
       */
      public int getRevisionHistoryLimit() {
        return revisionHistoryLimit_;
      }
      /**
       * <pre>
       * The number of old history to retain to allow rollback.
       * This is a pointer to distinguish between explicit zero and not specified.
       * Defaults to 10.
       * +optional
       * </pre>
       *
       * <code>optional int32 revisionHistoryLimit = 6;</code>
       */
      public Builder setRevisionHistoryLimit(int value) {
        bitField0_ |= 0x00000010;
        revisionHistoryLimit_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The number of old history to retain to allow rollback.
       * This is a pointer to distinguish between explicit zero and not specified.
       * Defaults to 10.
       * +optional
       * </pre>
       *
       * <code>optional int32 revisionHistoryLimit = 6;</code>
       */
      public Builder clearRevisionHistoryLimit() {
        bitField0_ = (bitField0_ & ~0x00000010);
        revisionHistoryLimit_ = 0;
        onChanged();
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.apps.v1.DaemonSetSpec)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.apps.v1.DaemonSetSpec)
    private static final io.kubernetes.client.proto.V1Apps.DaemonSetSpec DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Apps.DaemonSetSpec();
    }

    public static io.kubernetes.client.proto.V1Apps.DaemonSetSpec getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<DaemonSetSpec>
        PARSER = new com.google.protobuf.AbstractParser<DaemonSetSpec>() {
      public DaemonSetSpec parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
          return new DaemonSetSpec(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<DaemonSetSpec> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<DaemonSetSpec> getParserForType() {
      return PARSER;
    }

    public io.kubernetes.client.proto.V1Apps.DaemonSetSpec getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface DaemonSetStatusOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.apps.v1.DaemonSetStatus)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The number of nodes that are running at least 1
     * daemon pod and are supposed to run the daemon pod.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
     * </pre>
     *
     * <code>optional int32 currentNumberScheduled = 1;</code>
     */
    boolean hasCurrentNumberScheduled();
    /**
     * <pre>
     * The number of nodes that are running at least 1
     * daemon pod and are supposed to run the daemon pod.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
     * </pre>
     *
     * <code>optional int32 currentNumberScheduled = 1;</code>
     */
    int getCurrentNumberScheduled();

    /**
     * <pre>
     * The number of nodes that are running the daemon pod, but are
     * not supposed to run the daemon pod.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
     * </pre>
     *
     * <code>optional int32 numberMisscheduled = 2;</code>
     */
    boolean hasNumberMisscheduled();
    /**
     * <pre>
     * The number of nodes that are running the daemon pod, but are
     * not supposed to run the daemon pod.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
     * </pre>
     *
     * <code>optional int32 numberMisscheduled = 2;</code>
     */
    int getNumberMisscheduled();

    /**
     * <pre>
     * The total number of nodes that should be running the daemon
     * pod (including nodes correctly running the daemon pod).
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
     * </pre>
     *
     * <code>optional int32 desiredNumberScheduled = 3;</code>
     */
    boolean hasDesiredNumberScheduled();
    /**
     * <pre>
     * The total number of nodes that should be running the daemon
     * pod (including nodes correctly running the daemon pod).
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
     * </pre>
     *
     * <code>optional int32 desiredNumberScheduled = 3;</code>
     */
    int getDesiredNumberScheduled();

    /**
     * <pre>
     * The number of nodes that should be running the daemon pod and have one
     * or more of the daemon pod running and ready.
     * </pre>
     *
     * <code>optional int32 numberReady = 4;</code>
     */
    boolean hasNumberReady();
    /**
     * <pre>
     * The number of nodes that should be running the daemon pod and have one
     * or more of the daemon pod running and ready.
     * </pre>
     *
     * <code>optional int32 numberReady = 4;</code>
     */
    int getNumberReady();

    /**
     * <pre>
     * The most recent generation observed by the daemon set controller.
     * +optional
     * </pre>
     *
     * <code>optional int64 observedGeneration = 5;</code>
     */
    boolean hasObservedGeneration();
    /**
     * <pre>
     * The most recent generation observed by the daemon set controller.
     * +optional
     * </pre>
     *
     * <code>optional int64 observedGeneration = 5;</code>
     */
    long getObservedGeneration();

    /**
     * <pre>
     * The total number of nodes that are running updated daemon pod
     * +optional
     * </pre>
     *
     * <code>optional int32 updatedNumberScheduled = 6;</code>
     */
    boolean hasUpdatedNumberScheduled();
    /**
     * <pre>
     * The total number of nodes that are running updated daemon pod
     * +optional
     * </pre>
     *
     * <code>optional int32 updatedNumberScheduled = 6;</code>
     */
    int getUpdatedNumberScheduled();

    /**
     * <pre>
     * The number of nodes that should be running the
     * daemon pod and have one or more of the daemon pod running and
     * available (ready for at least spec.minReadySeconds)
     * +optional
     * </pre>
     *
     * <code>optional int32 numberAvailable = 7;</code>
     */
    boolean hasNumberAvailable();
    /**
     * <pre>
     * The number of nodes that should be running the
     * daemon pod and have one or more of the daemon pod running and
     * available (ready for at least spec.minReadySeconds)
     * +optional
     * </pre>
     *
     * <code>optional int32 numberAvailable = 7;</code>
     */
    int getNumberAvailable();

    /**
     * <pre>
     * The number of nodes that should be running the
     * daemon pod and have none of the daemon pod running and available
     * (ready for at least spec.minReadySeconds)
     * +optional
     * </pre>
     *
     * <code>optional int32 numberUnavailable = 8;</code>
     */
    boolean hasNumberUnavailable();
    /**
     * <pre>
     * The number of nodes that should be running the
     * daemon pod and have none of the daemon pod running and available
     * (ready for at least spec.minReadySeconds)
     * +optional
     * </pre>
     *
     * <code>optional int32 numberUnavailable = 8;</code>
     */
    int getNumberUnavailable();

    /**
     * <pre>
     * Count of hash collisions for the DaemonSet. The DaemonSet controller
     * uses this field as a collision avoidance mechanism when it needs to
     * create the name for the newest ControllerRevision.
     * +optional
     * </pre>
     *
     * <code>optional int32 collisionCount = 9;</code>
     */
    boolean hasCollisionCount();
    /**
     * <pre>
     * Count of hash collisions for the DaemonSet. The DaemonSet controller
     * uses this field as a collision avoidance mechanism when it needs to
     * create the name for the newest ControllerRevision.
     * +optional
     * </pre>
     *
     * <code>optional int32 collisionCount = 9;</code>
     */
    int getCollisionCount();
  }
  /**
   * <pre>
   * DaemonSetStatus represents the current status of a daemon set.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.apps.v1.DaemonSetStatus}
   */
  public  static final class DaemonSetStatus extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.apps.v1.DaemonSetStatus)
      DaemonSetStatusOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use DaemonSetStatus.newBuilder() to construct.
    private DaemonSetStatus(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private DaemonSetStatus() {
      currentNumberScheduled_ = 0;
      numberMisscheduled_ = 0;
      desiredNumberScheduled_ = 0;
      numberReady_ = 0;
      observedGeneration_ = 0L;
      updatedNumberScheduled_ = 0;
      numberAvailable_ = 0;
      numberUnavailable_ = 0;
      collisionCount_ = 0;
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private DaemonSetStatus(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 8: {
              bitField0_ |= 0x00000001;
              currentNumberScheduled_ = input.readInt32();
              break;
            }
            case 16: {
              bitField0_ |= 0x00000002;
              numberMisscheduled_ = input.readInt32();
              break;
            }
            case 24: {
              bitField0_ |= 0x00000004;
              desiredNumberScheduled_ = input.readInt32();
              break;
            }
            case 32: {
              bitField0_ |= 0x00000008;
              numberReady_ = input.readInt32();
              break;
            }
            case 40: {
              bitField0_ |= 0x00000010;
              observedGeneration_ = input.readInt64();
              break;
            }
            case 48: {
              bitField0_ |= 0x00000020;
              updatedNumberScheduled_ = input.readInt32();
              break;
            }
            case 56: {
              bitField0_ |= 0x00000040;
              numberAvailable_ = input.readInt32();
              break;
            }
            case 64: {
              bitField0_ |= 0x00000080;
              numberUnavailable_ = input.readInt32();
              break;
            }
            case 72: {
              bitField0_ |= 0x00000100;
              collisionCount_ = input.readInt32();
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DaemonSetStatus_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DaemonSetStatus_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Apps.DaemonSetStatus.class, io.kubernetes.client.proto.V1Apps.DaemonSetStatus.Builder.class);
    }

    private int bitField0_;
    public static final int CURRENTNUMBERSCHEDULED_FIELD_NUMBER = 1;
    private int currentNumberScheduled_;
    /**
     * <pre>
     * The number of nodes that are running at least 1
     * daemon pod and are supposed to run the daemon pod.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
     * </pre>
     *
     * <code>optional int32 currentNumberScheduled = 1;</code>
     */
    public boolean hasCurrentNumberScheduled() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * The number of nodes that are running at least 1
     * daemon pod and are supposed to run the daemon pod.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
     * </pre>
     *
     * <code>optional int32 currentNumberScheduled = 1;</code>
     */
    public int getCurrentNumberScheduled() {
      return currentNumberScheduled_;
    }

    public static final int NUMBERMISSCHEDULED_FIELD_NUMBER = 2;
    private int numberMisscheduled_;
    /**
     * <pre>
     * The number of nodes that are running the daemon pod, but are
     * not supposed to run the daemon pod.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
     * </pre>
     *
     * <code>optional int32 numberMisscheduled = 2;</code>
     */
    public boolean hasNumberMisscheduled() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * The number of nodes that are running the daemon pod, but are
     * not supposed to run the daemon pod.
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
     * </pre>
     *
     * <code>optional int32 numberMisscheduled = 2;</code>
     */
    public int getNumberMisscheduled() {
      return numberMisscheduled_;
    }

    public static final int DESIREDNUMBERSCHEDULED_FIELD_NUMBER = 3;
    private int desiredNumberScheduled_;
    /**
     * <pre>
     * The total number of nodes that should be running the daemon
     * pod (including nodes correctly running the daemon pod).
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
     * </pre>
     *
     * <code>optional int32 desiredNumberScheduled = 3;</code>
     */
    public boolean hasDesiredNumberScheduled() {
      return ((bitField0_ & 0x00000004) == 0x00000004);
    }
    /**
     * <pre>
     * The total number of nodes that should be running the daemon
     * pod (including nodes correctly running the daemon pod).
     * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
     * </pre>
     *
     * <code>optional int32 desiredNumberScheduled = 3;</code>
     */
    public int getDesiredNumberScheduled() {
      return desiredNumberScheduled_;
    }

    public static final int NUMBERREADY_FIELD_NUMBER = 4;
    private int numberReady_;
    /**
     * <pre>
     * The number of nodes that should be running the daemon pod and have one
     * or more of the daemon pod running and ready.
     * </pre>
     *
     * <code>optional int32 numberReady = 4;</code>
     */
    public boolean hasNumberReady() {
      return ((bitField0_ & 0x00000008) == 0x00000008);
    }
    /**
     * <pre>
     * The number of nodes that should be running the daemon pod and have one
     * or more of the daemon pod running and ready.
     * </pre>
     *
     * <code>optional int32 numberReady = 4;</code>
     */
    public int getNumberReady() {
      return numberReady_;
    }

    public static final int OBSERVEDGENERATION_FIELD_NUMBER = 5;
    private long observedGeneration_;
    /**
     * <pre>
     * The most recent generation observed by the daemon set controller.
     * +optional
     * </pre>
     *
     * <code>optional int64 observedGeneration = 5;</code>
     */
    public boolean hasObservedGeneration() {
      return ((bitField0_ & 0x00000010) == 0x00000010);
    }
    /**
     * <pre>
     * The most recent generation observed by the daemon set controller.
     * +optional
     * </pre>
     *
     * <code>optional int64 observedGeneration = 5;</code>
     */
    public long getObservedGeneration() {
      return observedGeneration_;
    }

    public static final int UPDATEDNUMBERSCHEDULED_FIELD_NUMBER = 6;
    private int updatedNumberScheduled_;
    /**
     * <pre>
     * The total number of nodes that are running updated daemon pod
     * +optional
     * </pre>
     *
     * <code>optional int32 updatedNumberScheduled = 6;</code>
     */
    public boolean hasUpdatedNumberScheduled() {
      return ((bitField0_ & 0x00000020) == 0x00000020);
    }
    /**
     * <pre>
     * The total number of nodes that are running updated daemon pod
     * +optional
     * </pre>
     *
     * <code>optional int32 updatedNumberScheduled = 6;</code>
     */
    public int getUpdatedNumberScheduled() {
      return updatedNumberScheduled_;
    }

    public static final int NUMBERAVAILABLE_FIELD_NUMBER = 7;
    private int numberAvailable_;
    /**
     * <pre>
     * The number of nodes that should be running the
     * daemon pod and have one or more of the daemon pod running and
     * available (ready for at least spec.minReadySeconds)
     * +optional
     * </pre>
     *
     * <code>optional int32 numberAvailable = 7;</code>
     */
    public boolean hasNumberAvailable() {
      return ((bitField0_ & 0x00000040) == 0x00000040);
    }
    /**
     * <pre>
     * The number of nodes that should be running the
     * daemon pod and have one or more of the daemon pod running and
     * available (ready for at least spec.minReadySeconds)
     * +optional
     * </pre>
     *
     * <code>optional int32 numberAvailable = 7;</code>
     */
    public int getNumberAvailable() {
      return numberAvailable_;
    }

    public static final int NUMBERUNAVAILABLE_FIELD_NUMBER = 8;
    private int numberUnavailable_;
    /**
     * <pre>
     * The number of nodes that should be running the
     * daemon pod and have none of the daemon pod running and available
     * (ready for at least spec.minReadySeconds)
     * +optional
     * </pre>
     *
     * <code>optional int32 numberUnavailable = 8;</code>
     */
    public boolean hasNumberUnavailable() {
      return ((bitField0_ & 0x00000080) == 0x00000080);
    }
    /**
     * <pre>
     * The number of nodes that should be running the
     * daemon pod and have none of the daemon pod running and available
     * (ready for at least spec.minReadySeconds)
     * +optional
     * </pre>
     *
     * <code>optional int32 numberUnavailable = 8;</code>
     */
    public int getNumberUnavailable() {
      return numberUnavailable_;
    }

    public static final int COLLISIONCOUNT_FIELD_NUMBER = 9;
    private int collisionCount_;
    /**
     * <pre>
     * Count of hash collisions for the DaemonSet. The DaemonSet controller
     * uses this field as a collision avoidance mechanism when it needs to
     * create the name for the newest ControllerRevision.
     * +optional
     * </pre>
     *
     * <code>optional int32 collisionCount = 9;</code>
     */
    public boolean hasCollisionCount() {
      return ((bitField0_ & 0x00000100) == 0x00000100);
    }
    /**
     * <pre>
     * Count of hash collisions for the DaemonSet. The DaemonSet controller
     * uses this field as a collision avoidance mechanism when it needs to
     * create the name for the newest ControllerRevision.
     * +optional
     * </pre>
     *
     * <code>optional int32 collisionCount = 9;</code>
     */
    public int getCollisionCount() {
      return collisionCount_;
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeInt32(1, currentNumberScheduled_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeInt32(2, numberMisscheduled_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        output.writeInt32(3, desiredNumberScheduled_);
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        output.writeInt32(4, numberReady_);
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        output.writeInt64(5, observedGeneration_);
      }
      if (((bitField0_ & 0x00000020) == 0x00000020)) {
        output.writeInt32(6, updatedNumberScheduled_);
      }
      if (((bitField0_ & 0x00000040) == 0x00000040)) {
        output.writeInt32(7, numberAvailable_);
      }
      if (((bitField0_ & 0x00000080) == 0x00000080)) {
        output.writeInt32(8, numberUnavailable_);
      }
      if (((bitField0_ & 0x00000100) == 0x00000100)) {
        output.writeInt32(9, collisionCount_);
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(1, currentNumberScheduled_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(2, numberMisscheduled_);
      }
      if (((bitField0_ & 0x00000004) == 0x00000004)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(3, desiredNumberScheduled_);
      }
      if (((bitField0_ & 0x00000008) == 0x00000008)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(4, numberReady_);
      }
      if (((bitField0_ & 0x00000010) == 0x00000010)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt64Size(5, observedGeneration_);
      }
      if (((bitField0_ & 0x00000020) == 0x00000020)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(6, updatedNumberScheduled_);
      }
      if (((bitField0_ & 0x00000040) == 0x00000040)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(7, numberAvailable_);
      }
      if (((bitField0_ & 0x00000080) == 0x00000080)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(8, numberUnavailable_);
      }
      if (((bitField0_ & 0x00000100) == 0x00000100)) {
        size += com.google.protobuf.CodedOutputStream
          .computeInt32Size(9, collisionCount_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Apps.DaemonSetStatus)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Apps.DaemonSetStatus other = (io.kubernetes.client.proto.V1Apps.DaemonSetStatus) obj;

      boolean result = true;
      result = result && (hasCurrentNumberScheduled() == other.hasCurrentNumberScheduled());
      if (hasCurrentNumberScheduled()) {
        result = result && (getCurrentNumberScheduled()
            == other.getCurrentNumberScheduled());
      }
      result = result && (hasNumberMisscheduled() == other.hasNumberMisscheduled());
      if (hasNumberMisscheduled()) {
        result = result && (getNumberMisscheduled()
            == other.getNumberMisscheduled());
      }
      result = result && (hasDesiredNumberScheduled() == other.hasDesiredNumberScheduled());
      if (hasDesiredNumberScheduled()) {
        result = result && (getDesiredNumberScheduled()
            == other.getDesiredNumberScheduled());
      }
      result = result && (hasNumberReady() == other.hasNumberReady());
      if (hasNumberReady()) {
        result = result && (getNumberReady()
            == other.getNumberReady());
      }
      result = result && (hasObservedGeneration() == other.hasObservedGeneration());
      if (hasObservedGeneration()) {
        result = result && (getObservedGeneration()
            == other.getObservedGeneration());
      }
      result = result && (hasUpdatedNumberScheduled() == other.hasUpdatedNumberScheduled());
      if (hasUpdatedNumberScheduled()) {
        result = result && (getUpdatedNumberScheduled()
            == other.getUpdatedNumberScheduled());
      }
      result = result && (hasNumberAvailable() == other.hasNumberAvailable());
      if (hasNumberAvailable()) {
        result = result && (getNumberAvailable()
            == other.getNumberAvailable());
      }
      result = result && (hasNumberUnavailable() == other.hasNumberUnavailable());
      if (hasNumberUnavailable()) {
        result = result && (getNumberUnavailable()
            == other.getNumberUnavailable());
      }
      result = result && (hasCollisionCount() == other.hasCollisionCount());
      if (hasCollisionCount()) {
        result = result && (getCollisionCount()
            == other.getCollisionCount());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasCurrentNumberScheduled()) {
        hash = (37 * hash) + CURRENTNUMBERSCHEDULED_FIELD_NUMBER;
        hash = (53 * hash) + getCurrentNumberScheduled();
      }
      if (hasNumberMisscheduled()) {
        hash = (37 * hash) + NUMBERMISSCHEDULED_FIELD_NUMBER;
        hash = (53 * hash) + getNumberMisscheduled();
      }
      if (hasDesiredNumberScheduled()) {
        hash = (37 * hash) + DESIREDNUMBERSCHEDULED_FIELD_NUMBER;
        hash = (53 * hash) + getDesiredNumberScheduled();
      }
      if (hasNumberReady()) {
        hash = (37 * hash) + NUMBERREADY_FIELD_NUMBER;
        hash = (53 * hash) + getNumberReady();
      }
      if (hasObservedGeneration()) {
        hash = (37 * hash) + OBSERVEDGENERATION_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getObservedGeneration());
      }
      if (hasUpdatedNumberScheduled()) {
        hash = (37 * hash) + UPDATEDNUMBERSCHEDULED_FIELD_NUMBER;
        hash = (53 * hash) + getUpdatedNumberScheduled();
      }
      if (hasNumberAvailable()) {
        hash = (37 * hash) + NUMBERAVAILABLE_FIELD_NUMBER;
        hash = (53 * hash) + getNumberAvailable();
      }
      if (hasNumberUnavailable()) {
        hash = (37 * hash) + NUMBERUNAVAILABLE_FIELD_NUMBER;
        hash = (53 * hash) + getNumberUnavailable();
      }
      if (hasCollisionCount()) {
        hash = (37 * hash) + COLLISIONCOUNT_FIELD_NUMBER;
        hash = (53 * hash) + getCollisionCount();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Apps.DaemonSetStatus parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetStatus parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetStatus parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetStatus parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetStatus parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetStatus parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetStatus parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetStatus parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetStatus parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetStatus parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetStatus parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetStatus parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Apps.DaemonSetStatus prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * DaemonSetStatus represents the current status of a daemon set.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.apps.v1.DaemonSetStatus}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.apps.v1.DaemonSetStatus)
        io.kubernetes.client.proto.V1Apps.DaemonSetStatusOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DaemonSetStatus_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DaemonSetStatus_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Apps.DaemonSetStatus.class, io.kubernetes.client.proto.V1Apps.DaemonSetStatus.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Apps.DaemonSetStatus.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        currentNumberScheduled_ = 0;
        bitField0_ = (bitField0_ & ~0x00000001);
        numberMisscheduled_ = 0;
        bitField0_ = (bitField0_ & ~0x00000002);
        desiredNumberScheduled_ = 0;
        bitField0_ = (bitField0_ & ~0x00000004);
        numberReady_ = 0;
        bitField0_ = (bitField0_ & ~0x00000008);
        observedGeneration_ = 0L;
        bitField0_ = (bitField0_ & ~0x00000010);
        updatedNumberScheduled_ = 0;
        bitField0_ = (bitField0_ & ~0x00000020);
        numberAvailable_ = 0;
        bitField0_ = (bitField0_ & ~0x00000040);
        numberUnavailable_ = 0;
        bitField0_ = (bitField0_ & ~0x00000080);
        collisionCount_ = 0;
        bitField0_ = (bitField0_ & ~0x00000100);
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DaemonSetStatus_descriptor;
      }

      public io.kubernetes.client.proto.V1Apps.DaemonSetStatus getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Apps.DaemonSetStatus.getDefaultInstance();
      }

      public io.kubernetes.client.proto.V1Apps.DaemonSetStatus build() {
        io.kubernetes.client.proto.V1Apps.DaemonSetStatus result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public io.kubernetes.client.proto.V1Apps.DaemonSetStatus buildPartial() {
        io.kubernetes.client.proto.V1Apps.DaemonSetStatus result = new io.kubernetes.client.proto.V1Apps.DaemonSetStatus(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.currentNumberScheduled_ = currentNumberScheduled_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        result.numberMisscheduled_ = numberMisscheduled_;
        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
          to_bitField0_ |= 0x00000004;
        }
        result.desiredNumberScheduled_ = desiredNumberScheduled_;
        if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
          to_bitField0_ |= 0x00000008;
        }
        result.numberReady_ = numberReady_;
        if (((from_bitField0_ & 0x00000010) == 0x00000010)) {
          to_bitField0_ |= 0x00000010;
        }
        result.observedGeneration_ = observedGeneration_;
        if (((from_bitField0_ & 0x00000020) == 0x00000020)) {
          to_bitField0_ |= 0x00000020;
        }
        result.updatedNumberScheduled_ = updatedNumberScheduled_;
        if (((from_bitField0_ & 0x00000040) == 0x00000040)) {
          to_bitField0_ |= 0x00000040;
        }
        result.numberAvailable_ = numberAvailable_;
        if (((from_bitField0_ & 0x00000080) == 0x00000080)) {
          to_bitField0_ |= 0x00000080;
        }
        result.numberUnavailable_ = numberUnavailable_;
        if (((from_bitField0_ & 0x00000100) == 0x00000100)) {
          to_bitField0_ |= 0x00000100;
        }
        result.collisionCount_ = collisionCount_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Apps.DaemonSetStatus) {
          return mergeFrom((io.kubernetes.client.proto.V1Apps.DaemonSetStatus)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Apps.DaemonSetStatus other) {
        if (other == io.kubernetes.client.proto.V1Apps.DaemonSetStatus.getDefaultInstance()) return this;
        if (other.hasCurrentNumberScheduled()) {
          setCurrentNumberScheduled(other.getCurrentNumberScheduled());
        }
        if (other.hasNumberMisscheduled()) {
          setNumberMisscheduled(other.getNumberMisscheduled());
        }
        if (other.hasDesiredNumberScheduled()) {
          setDesiredNumberScheduled(other.getDesiredNumberScheduled());
        }
        if (other.hasNumberReady()) {
          setNumberReady(other.getNumberReady());
        }
        if (other.hasObservedGeneration()) {
          setObservedGeneration(other.getObservedGeneration());
        }
        if (other.hasUpdatedNumberScheduled()) {
          setUpdatedNumberScheduled(other.getUpdatedNumberScheduled());
        }
        if (other.hasNumberAvailable()) {
          setNumberAvailable(other.getNumberAvailable());
        }
        if (other.hasNumberUnavailable()) {
          setNumberUnavailable(other.getNumberUnavailable());
        }
        if (other.hasCollisionCount()) {
          setCollisionCount(other.getCollisionCount());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1Apps.DaemonSetStatus parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1Apps.DaemonSetStatus) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private int currentNumberScheduled_ ;
      /**
       * <pre>
       * The number of nodes that are running at least 1
       * daemon pod and are supposed to run the daemon pod.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
       * </pre>
       *
       * <code>optional int32 currentNumberScheduled = 1;</code>
       */
      public boolean hasCurrentNumberScheduled() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * The number of nodes that are running at least 1
       * daemon pod and are supposed to run the daemon pod.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
       * </pre>
       *
       * <code>optional int32 currentNumberScheduled = 1;</code>
       */
      public int getCurrentNumberScheduled() {
        return currentNumberScheduled_;
      }
      /**
       * <pre>
       * The number of nodes that are running at least 1
       * daemon pod and are supposed to run the daemon pod.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
       * </pre>
       *
       * <code>optional int32 currentNumberScheduled = 1;</code>
       */
      public Builder setCurrentNumberScheduled(int value) {
        bitField0_ |= 0x00000001;
        currentNumberScheduled_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The number of nodes that are running at least 1
       * daemon pod and are supposed to run the daemon pod.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
       * </pre>
       *
       * <code>optional int32 currentNumberScheduled = 1;</code>
       */
      public Builder clearCurrentNumberScheduled() {
        bitField0_ = (bitField0_ & ~0x00000001);
        currentNumberScheduled_ = 0;
        onChanged();
        return this;
      }

      private int numberMisscheduled_ ;
      /**
       * <pre>
       * The number of nodes that are running the daemon pod, but are
       * not supposed to run the daemon pod.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
       * </pre>
       *
       * <code>optional int32 numberMisscheduled = 2;</code>
       */
      public boolean hasNumberMisscheduled() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <pre>
       * The number of nodes that are running the daemon pod, but are
       * not supposed to run the daemon pod.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
       * </pre>
       *
       * <code>optional int32 numberMisscheduled = 2;</code>
       */
      public int getNumberMisscheduled() {
        return numberMisscheduled_;
      }
      /**
       * <pre>
       * The number of nodes that are running the daemon pod, but are
       * not supposed to run the daemon pod.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
       * </pre>
       *
       * <code>optional int32 numberMisscheduled = 2;</code>
       */
      public Builder setNumberMisscheduled(int value) {
        bitField0_ |= 0x00000002;
        numberMisscheduled_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The number of nodes that are running the daemon pod, but are
       * not supposed to run the daemon pod.
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
       * </pre>
       *
       * <code>optional int32 numberMisscheduled = 2;</code>
       */
      public Builder clearNumberMisscheduled() {
        bitField0_ = (bitField0_ & ~0x00000002);
        numberMisscheduled_ = 0;
        onChanged();
        return this;
      }

      private int desiredNumberScheduled_ ;
      /**
       * <pre>
       * The total number of nodes that should be running the daemon
       * pod (including nodes correctly running the daemon pod).
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
       * </pre>
       *
       * <code>optional int32 desiredNumberScheduled = 3;</code>
       */
      public boolean hasDesiredNumberScheduled() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       * <pre>
       * The total number of nodes that should be running the daemon
       * pod (including nodes correctly running the daemon pod).
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
       * </pre>
       *
       * <code>optional int32 desiredNumberScheduled = 3;</code>
       */
      public int getDesiredNumberScheduled() {
        return desiredNumberScheduled_;
      }
      /**
       * <pre>
       * The total number of nodes that should be running the daemon
       * pod (including nodes correctly running the daemon pod).
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
       * </pre>
       *
       * <code>optional int32 desiredNumberScheduled = 3;</code>
       */
      public Builder setDesiredNumberScheduled(int value) {
        bitField0_ |= 0x00000004;
        desiredNumberScheduled_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The total number of nodes that should be running the daemon
       * pod (including nodes correctly running the daemon pod).
       * More info: https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/
       * </pre>
       *
       * <code>optional int32 desiredNumberScheduled = 3;</code>
       */
      public Builder clearDesiredNumberScheduled() {
        bitField0_ = (bitField0_ & ~0x00000004);
        desiredNumberScheduled_ = 0;
        onChanged();
        return this;
      }

      private int numberReady_ ;
      /**
       * <pre>
       * The number of nodes that should be running the daemon pod and have one
       * or more of the daemon pod running and ready.
       * </pre>
       *
       * <code>optional int32 numberReady = 4;</code>
       */
      public boolean hasNumberReady() {
        return ((bitField0_ & 0x00000008) == 0x00000008);
      }
      /**
       * <pre>
       * The number of nodes that should be running the daemon pod and have one
       * or more of the daemon pod running and ready.
       * </pre>
       *
       * <code>optional int32 numberReady = 4;</code>
       */
      public int getNumberReady() {
        return numberReady_;
      }
      /**
       * <pre>
       * The number of nodes that should be running the daemon pod and have one
       * or more of the daemon pod running and ready.
       * </pre>
       *
       * <code>optional int32 numberReady = 4;</code>
       */
      public Builder setNumberReady(int value) {
        bitField0_ |= 0x00000008;
        numberReady_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The number of nodes that should be running the daemon pod and have one
       * or more of the daemon pod running and ready.
       * </pre>
       *
       * <code>optional int32 numberReady = 4;</code>
       */
      public Builder clearNumberReady() {
        bitField0_ = (bitField0_ & ~0x00000008);
        numberReady_ = 0;
        onChanged();
        return this;
      }

      private long observedGeneration_ ;
      /**
       * <pre>
       * The most recent generation observed by the daemon set controller.
       * +optional
       * </pre>
       *
       * <code>optional int64 observedGeneration = 5;</code>
       */
      public boolean hasObservedGeneration() {
        return ((bitField0_ & 0x00000010) == 0x00000010);
      }
      /**
       * <pre>
       * The most recent generation observed by the daemon set controller.
       * +optional
       * </pre>
       *
       * <code>optional int64 observedGeneration = 5;</code>
       */
      public long getObservedGeneration() {
        return observedGeneration_;
      }
      /**
       * <pre>
       * The most recent generation observed by the daemon set controller.
       * +optional
       * </pre>
       *
       * <code>optional int64 observedGeneration = 5;</code>
       */
      public Builder setObservedGeneration(long value) {
        bitField0_ |= 0x00000010;
        observedGeneration_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The most recent generation observed by the daemon set controller.
       * +optional
       * </pre>
       *
       * <code>optional int64 observedGeneration = 5;</code>
       */
      public Builder clearObservedGeneration() {
        bitField0_ = (bitField0_ & ~0x00000010);
        observedGeneration_ = 0L;
        onChanged();
        return this;
      }

      private int updatedNumberScheduled_ ;
      /**
       * <pre>
       * The total number of nodes that are running updated daemon pod
       * +optional
       * </pre>
       *
       * <code>optional int32 updatedNumberScheduled = 6;</code>
       */
      public boolean hasUpdatedNumberScheduled() {
        return ((bitField0_ & 0x00000020) == 0x00000020);
      }
      /**
       * <pre>
       * The total number of nodes that are running updated daemon pod
       * +optional
       * </pre>
       *
       * <code>optional int32 updatedNumberScheduled = 6;</code>
       */
      public int getUpdatedNumberScheduled() {
        return updatedNumberScheduled_;
      }
      /**
       * <pre>
       * The total number of nodes that are running updated daemon pod
       * +optional
       * </pre>
       *
       * <code>optional int32 updatedNumberScheduled = 6;</code>
       */
      public Builder setUpdatedNumberScheduled(int value) {
        bitField0_ |= 0x00000020;
        updatedNumberScheduled_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The total number of nodes that are running updated daemon pod
       * +optional
       * </pre>
       *
       * <code>optional int32 updatedNumberScheduled = 6;</code>
       */
      public Builder clearUpdatedNumberScheduled() {
        bitField0_ = (bitField0_ & ~0x00000020);
        updatedNumberScheduled_ = 0;
        onChanged();
        return this;
      }

      private int numberAvailable_ ;
      /**
       * <pre>
       * The number of nodes that should be running the
       * daemon pod and have one or more of the daemon pod running and
       * available (ready for at least spec.minReadySeconds)
       * +optional
       * </pre>
       *
       * <code>optional int32 numberAvailable = 7;</code>
       */
      public boolean hasNumberAvailable() {
        return ((bitField0_ & 0x00000040) == 0x00000040);
      }
      /**
       * <pre>
       * The number of nodes that should be running the
       * daemon pod and have one or more of the daemon pod running and
       * available (ready for at least spec.minReadySeconds)
       * +optional
       * </pre>
       *
       * <code>optional int32 numberAvailable = 7;</code>
       */
      public int getNumberAvailable() {
        return numberAvailable_;
      }
      /**
       * <pre>
       * The number of nodes that should be running the
       * daemon pod and have one or more of the daemon pod running and
       * available (ready for at least spec.minReadySeconds)
       * +optional
       * </pre>
       *
       * <code>optional int32 numberAvailable = 7;</code>
       */
      public Builder setNumberAvailable(int value) {
        bitField0_ |= 0x00000040;
        numberAvailable_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The number of nodes that should be running the
       * daemon pod and have one or more of the daemon pod running and
       * available (ready for at least spec.minReadySeconds)
       * +optional
       * </pre>
       *
       * <code>optional int32 numberAvailable = 7;</code>
       */
      public Builder clearNumberAvailable() {
        bitField0_ = (bitField0_ & ~0x00000040);
        numberAvailable_ = 0;
        onChanged();
        return this;
      }

      private int numberUnavailable_ ;
      /**
       * <pre>
       * The number of nodes that should be running the
       * daemon pod and have none of the daemon pod running and available
       * (ready for at least spec.minReadySeconds)
       * +optional
       * </pre>
       *
       * <code>optional int32 numberUnavailable = 8;</code>
       */
      public boolean hasNumberUnavailable() {
        return ((bitField0_ & 0x00000080) == 0x00000080);
      }
      /**
       * <pre>
       * The number of nodes that should be running the
       * daemon pod and have none of the daemon pod running and available
       * (ready for at least spec.minReadySeconds)
       * +optional
       * </pre>
       *
       * <code>optional int32 numberUnavailable = 8;</code>
       */
      public int getNumberUnavailable() {
        return numberUnavailable_;
      }
      /**
       * <pre>
       * The number of nodes that should be running the
       * daemon pod and have none of the daemon pod running and available
       * (ready for at least spec.minReadySeconds)
       * +optional
       * </pre>
       *
       * <code>optional int32 numberUnavailable = 8;</code>
       */
      public Builder setNumberUnavailable(int value) {
        bitField0_ |= 0x00000080;
        numberUnavailable_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The number of nodes that should be running the
       * daemon pod and have none of the daemon pod running and available
       * (ready for at least spec.minReadySeconds)
       * +optional
       * </pre>
       *
       * <code>optional int32 numberUnavailable = 8;</code>
       */
      public Builder clearNumberUnavailable() {
        bitField0_ = (bitField0_ & ~0x00000080);
        numberUnavailable_ = 0;
        onChanged();
        return this;
      }

      private int collisionCount_ ;
      /**
       * <pre>
       * Count of hash collisions for the DaemonSet. The DaemonSet controller
       * uses this field as a collision avoidance mechanism when it needs to
       * create the name for the newest ControllerRevision.
       * +optional
       * </pre>
       *
       * <code>optional int32 collisionCount = 9;</code>
       */
      public boolean hasCollisionCount() {
        return ((bitField0_ & 0x00000100) == 0x00000100);
      }
      /**
       * <pre>
       * Count of hash collisions for the DaemonSet. The DaemonSet controller
       * uses this field as a collision avoidance mechanism when it needs to
       * create the name for the newest ControllerRevision.
       * +optional
       * </pre>
       *
       * <code>optional int32 collisionCount = 9;</code>
       */
      public int getCollisionCount() {
        return collisionCount_;
      }
      /**
       * <pre>
       * Count of hash collisions for the DaemonSet. The DaemonSet controller
       * uses this field as a collision avoidance mechanism when it needs to
       * create the name for the newest ControllerRevision.
       * +optional
       * </pre>
       *
       * <code>optional int32 collisionCount = 9;</code>
       */
      public Builder setCollisionCount(int value) {
        bitField0_ |= 0x00000100;
        collisionCount_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Count of hash collisions for the DaemonSet. The DaemonSet controller
       * uses this field as a collision avoidance mechanism when it needs to
       * create the name for the newest ControllerRevision.
       * +optional
       * </pre>
       *
       * <code>optional int32 collisionCount = 9;</code>
       */
      public Builder clearCollisionCount() {
        bitField0_ = (bitField0_ & ~0x00000100);
        collisionCount_ = 0;
        onChanged();
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.apps.v1.DaemonSetStatus)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.apps.v1.DaemonSetStatus)
    private static final io.kubernetes.client.proto.V1Apps.DaemonSetStatus DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Apps.DaemonSetStatus();
    }

    public static io.kubernetes.client.proto.V1Apps.DaemonSetStatus getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<DaemonSetStatus>
        PARSER = new com.google.protobuf.AbstractParser<DaemonSetStatus>() {
      public DaemonSetStatus parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
          return new DaemonSetStatus(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<DaemonSetStatus> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<DaemonSetStatus> getParserForType() {
      return PARSER;
    }

    public io.kubernetes.client.proto.V1Apps.DaemonSetStatus getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface DaemonSetUpdateStrategyOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.apps.v1.DaemonSetUpdateStrategy)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Type of daemon set update. Can be "RollingUpdate" or "OnDelete". Default is RollingUpdate.
     * +optional
     * </pre>
     *
     * <code>optional string type = 1;</code>
     */
    boolean hasType();
    /**
     * <pre>
     * Type of daemon set update. Can be "RollingUpdate" or "OnDelete". Default is RollingUpdate.
     * +optional
     * </pre>
     *
     * <code>optional string type = 1;</code>
     */
    java.lang.String getType();
    /**
     * <pre>
     * Type of daemon set update. Can be "RollingUpdate" or "OnDelete". Default is RollingUpdate.
     * +optional
     * </pre>
     *
     * <code>optional string type = 1;</code>
     */
    com.google.protobuf.ByteString
        getTypeBytes();

    /**
     * <pre>
     * Rolling update config params. Present only if type = "RollingUpdate".
     * ---
     * TODO: Update this to follow our convention for oneOf, whatever we decide it
     * to be. Same as Deployment `strategy.rollingUpdate`.
     * See https://github.com/kubernetes/kubernetes/issues/35345
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.RollingUpdateDaemonSet rollingUpdate = 2;</code>
     */
    boolean hasRollingUpdate();
    /**
     * <pre>
     * Rolling update config params. Present only if type = "RollingUpdate".
     * ---
     * TODO: Update this to follow our convention for oneOf, whatever we decide it
     * to be. Same as Deployment `strategy.rollingUpdate`.
     * See https://github.com/kubernetes/kubernetes/issues/35345
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.RollingUpdateDaemonSet rollingUpdate = 2;</code>
     */
    io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet getRollingUpdate();
    /**
     * <pre>
     * Rolling update config params. Present only if type = "RollingUpdate".
     * ---
     * TODO: Update this to follow our convention for oneOf, whatever we decide it
     * to be. Same as Deployment `strategy.rollingUpdate`.
     * See https://github.com/kubernetes/kubernetes/issues/35345
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.RollingUpdateDaemonSet rollingUpdate = 2;</code>
     */
    io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSetOrBuilder getRollingUpdateOrBuilder();
  }
  /**
   * <pre>
   * DaemonSetUpdateStrategy is a struct used to control the update strategy for a DaemonSet.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.apps.v1.DaemonSetUpdateStrategy}
   */
  public  static final class DaemonSetUpdateStrategy extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.apps.v1.DaemonSetUpdateStrategy)
      DaemonSetUpdateStrategyOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use DaemonSetUpdateStrategy.newBuilder() to construct.
    private DaemonSetUpdateStrategy(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private DaemonSetUpdateStrategy() {
      type_ = "";
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private DaemonSetUpdateStrategy(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              com.google.protobuf.ByteString bs = input.readBytes();
              bitField0_ |= 0x00000001;
              type_ = bs;
              break;
            }
            case 18: {
              io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet.Builder subBuilder = null;
              if (((bitField0_ & 0x00000002) == 0x00000002)) {
                subBuilder = rollingUpdate_.toBuilder();
              }
              rollingUpdate_ = input.readMessage(io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(rollingUpdate_);
                rollingUpdate_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000002;
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DaemonSetUpdateStrategy_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DaemonSetUpdateStrategy_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy.class, io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy.Builder.class);
    }

    private int bitField0_;
    public static final int TYPE_FIELD_NUMBER = 1;
    private volatile java.lang.Object type_;
    /**
     * <pre>
     * Type of daemon set update. Can be "RollingUpdate" or "OnDelete". Default is RollingUpdate.
     * +optional
     * </pre>
     *
     * <code>optional string type = 1;</code>
     */
    public boolean hasType() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * Type of daemon set update. Can be "RollingUpdate" or "OnDelete". Default is RollingUpdate.
     * +optional
     * </pre>
     *
     * <code>optional string type = 1;</code>
     */
    public java.lang.String getType() {
      java.lang.Object ref = type_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          type_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Type of daemon set update. Can be "RollingUpdate" or "OnDelete". Default is RollingUpdate.
     * +optional
     * </pre>
     *
     * <code>optional string type = 1;</code>
     */
    public com.google.protobuf.ByteString
        getTypeBytes() {
      java.lang.Object ref = type_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        type_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int ROLLINGUPDATE_FIELD_NUMBER = 2;
    private io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet rollingUpdate_;
    /**
     * <pre>
     * Rolling update config params. Present only if type = "RollingUpdate".
     * ---
     * TODO: Update this to follow our convention for oneOf, whatever we decide it
     * to be. Same as Deployment `strategy.rollingUpdate`.
     * See https://github.com/kubernetes/kubernetes/issues/35345
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.RollingUpdateDaemonSet rollingUpdate = 2;</code>
     */
    public boolean hasRollingUpdate() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }
    /**
     * <pre>
     * Rolling update config params. Present only if type = "RollingUpdate".
     * ---
     * TODO: Update this to follow our convention for oneOf, whatever we decide it
     * to be. Same as Deployment `strategy.rollingUpdate`.
     * See https://github.com/kubernetes/kubernetes/issues/35345
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.RollingUpdateDaemonSet rollingUpdate = 2;</code>
     */
    public io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet getRollingUpdate() {
      return rollingUpdate_ == null ? io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet.getDefaultInstance() : rollingUpdate_;
    }
    /**
     * <pre>
     * Rolling update config params. Present only if type = "RollingUpdate".
     * ---
     * TODO: Update this to follow our convention for oneOf, whatever we decide it
     * to be. Same as Deployment `strategy.rollingUpdate`.
     * See https://github.com/kubernetes/kubernetes/issues/35345
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.api.apps.v1.RollingUpdateDaemonSet rollingUpdate = 2;</code>
     */
    public io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSetOrBuilder getRollingUpdateOrBuilder() {
      return rollingUpdate_ == null ? io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet.getDefaultInstance() : rollingUpdate_;
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, type_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        output.writeMessage(2, getRollingUpdate());
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, type_);
      }
      if (((bitField0_ & 0x00000002) == 0x00000002)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getRollingUpdate());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy other = (io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy) obj;

      boolean result = true;
      result = result && (hasType() == other.hasType());
      if (hasType()) {
        result = result && getType()
            .equals(other.getType());
      }
      result = result && (hasRollingUpdate() == other.hasRollingUpdate());
      if (hasRollingUpdate()) {
        result = result && getRollingUpdate()
            .equals(other.getRollingUpdate());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasType()) {
        hash = (37 * hash) + TYPE_FIELD_NUMBER;
        hash = (53 * hash) + getType().hashCode();
      }
      if (hasRollingUpdate()) {
        hash = (37 * hash) + ROLLINGUPDATE_FIELD_NUMBER;
        hash = (53 * hash) + getRollingUpdate().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * DaemonSetUpdateStrategy is a struct used to control the update strategy for a DaemonSet.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.apps.v1.DaemonSetUpdateStrategy}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.apps.v1.DaemonSetUpdateStrategy)
        io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategyOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DaemonSetUpdateStrategy_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DaemonSetUpdateStrategy_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy.class, io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getRollingUpdateFieldBuilder();
        }
      }
      public Builder clear() {
        super.clear();
        type_ = "";
        bitField0_ = (bitField0_ & ~0x00000001);
        if (rollingUpdateBuilder_ == null) {
          rollingUpdate_ = null;
        } else {
          rollingUpdateBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_DaemonSetUpdateStrategy_descriptor;
      }

      public io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy.getDefaultInstance();
      }

      public io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy build() {
        io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy buildPartial() {
        io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy result = new io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.type_ = type_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        if (rollingUpdateBuilder_ == null) {
          result.rollingUpdate_ = rollingUpdate_;
        } else {
          result.rollingUpdate_ = rollingUpdateBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy) {
          return mergeFrom((io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy other) {
        if (other == io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy.getDefaultInstance()) return this;
        if (other.hasType()) {
          bitField0_ |= 0x00000001;
          type_ = other.type_;
          onChanged();
        }
        if (other.hasRollingUpdate()) {
          mergeRollingUpdate(other.getRollingUpdate());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.lang.Object type_ = "";
      /**
       * <pre>
       * Type of daemon set update. Can be "RollingUpdate" or "OnDelete". Default is RollingUpdate.
       * +optional
       * </pre>
       *
       * <code>optional string type = 1;</code>
       */
      public boolean hasType() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * Type of daemon set update. Can be "RollingUpdate" or "OnDelete". Default is RollingUpdate.
       * +optional
       * </pre>
       *
       * <code>optional string type = 1;</code>
       */
      public java.lang.String getType() {
        java.lang.Object ref = type_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            type_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Type of daemon set update. Can be "RollingUpdate" or "OnDelete". Default is RollingUpdate.
       * +optional
       * </pre>
       *
       * <code>optional string type = 1;</code>
       */
      public com.google.protobuf.ByteString
          getTypeBytes() {
        java.lang.Object ref = type_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          type_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Type of daemon set update. Can be "RollingUpdate" or "OnDelete". Default is RollingUpdate.
       * +optional
       * </pre>
       *
       * <code>optional string type = 1;</code>
       */
      public Builder setType(
          java.lang.String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        type_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Type of daemon set update. Can be "RollingUpdate" or "OnDelete". Default is RollingUpdate.
       * +optional
       * </pre>
       *
       * <code>optional string type = 1;</code>
       */
      public Builder clearType() {
        bitField0_ = (bitField0_ & ~0x00000001);
        type_ = getDefaultInstance().getType();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Type of daemon set update. Can be "RollingUpdate" or "OnDelete". Default is RollingUpdate.
       * +optional
       * </pre>
       *
       * <code>optional string type = 1;</code>
       */
      public Builder setTypeBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000001;
        type_ = value;
        onChanged();
        return this;
      }

      private io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet rollingUpdate_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet, io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet.Builder, io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSetOrBuilder> rollingUpdateBuilder_;
      /**
       * <pre>
       * Rolling update config params. Present only if type = "RollingUpdate".
       * ---
       * TODO: Update this to follow our convention for oneOf, whatever we decide it
       * to be. Same as Deployment `strategy.rollingUpdate`.
       * See https://github.com/kubernetes/kubernetes/issues/35345
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.RollingUpdateDaemonSet rollingUpdate = 2;</code>
       */
      public boolean hasRollingUpdate() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <pre>
       * Rolling update config params. Present only if type = "RollingUpdate".
       * ---
       * TODO: Update this to follow our convention for oneOf, whatever we decide it
       * to be. Same as Deployment `strategy.rollingUpdate`.
       * See https://github.com/kubernetes/kubernetes/issues/35345
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.RollingUpdateDaemonSet rollingUpdate = 2;</code>
       */
      public io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet getRollingUpdate() {
        if (rollingUpdateBuilder_ == null) {
          return rollingUpdate_ == null ? io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet.getDefaultInstance() : rollingUpdate_;
        } else {
          return rollingUpdateBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Rolling update config params. Present only if type = "RollingUpdate".
       * ---
       * TODO: Update this to follow our convention for oneOf, whatever we decide it
       * to be. Same as Deployment `strategy.rollingUpdate`.
       * See https://github.com/kubernetes/kubernetes/issues/35345
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.RollingUpdateDaemonSet rollingUpdate = 2;</code>
       */
      public Builder setRollingUpdate(io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet value) {
        if (rollingUpdateBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          rollingUpdate_ = value;
          onChanged();
        } else {
          rollingUpdateBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * Rolling update config params. Present only if type = "RollingUpdate".
       * ---
       * TODO: Update this to follow our convention for oneOf, whatever we decide it
       * to be. Same as Deployment `strategy.rollingUpdate`.
       * See https://github.com/kubernetes/kubernetes/issues/35345
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.RollingUpdateDaemonSet rollingUpdate = 2;</code>
       */
      public Builder setRollingUpdate(
          io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet.Builder builderForValue) {
        if (rollingUpdateBuilder_ == null) {
          rollingUpdate_ = builderForValue.build();
          onChanged();
        } else {
          rollingUpdateBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * Rolling update config params. Present only if type = "RollingUpdate".
       * ---
       * TODO: Update this to follow our convention for oneOf, whatever we decide it
       * to be. Same as Deployment `strategy.rollingUpdate`.
       * See https://github.com/kubernetes/kubernetes/issues/35345
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.RollingUpdateDaemonSet rollingUpdate = 2;</code>
       */
      public Builder mergeRollingUpdate(io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet value) {
        if (rollingUpdateBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002) &&
              rollingUpdate_ != null &&
              rollingUpdate_ != io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet.getDefaultInstance()) {
            rollingUpdate_ =
              io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet.newBuilder(rollingUpdate_).mergeFrom(value).buildPartial();
          } else {
            rollingUpdate_ = value;
          }
          onChanged();
        } else {
          rollingUpdateBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000002;
        return this;
      }
      /**
       * <pre>
       * Rolling update config params. Present only if type = "RollingUpdate".
       * ---
       * TODO: Update this to follow our convention for oneOf, whatever we decide it
       * to be. Same as Deployment `strategy.rollingUpdate`.
       * See https://github.com/kubernetes/kubernetes/issues/35345
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.RollingUpdateDaemonSet rollingUpdate = 2;</code>
       */
      public Builder clearRollingUpdate() {
        if (rollingUpdateBuilder_ == null) {
          rollingUpdate_ = null;
          onChanged();
        } else {
          rollingUpdateBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }
      /**
       * <pre>
       * Rolling update config params. Present only if type = "RollingUpdate".
       * ---
       * TODO: Update this to follow our convention for oneOf, whatever we decide it
       * to be. Same as Deployment `strategy.rollingUpdate`.
       * See https://github.com/kubernetes/kubernetes/issues/35345
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.RollingUpdateDaemonSet rollingUpdate = 2;</code>
       */
      public io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet.Builder getRollingUpdateBuilder() {
        bitField0_ |= 0x00000002;
        onChanged();
        return getRollingUpdateFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Rolling update config params. Present only if type = "RollingUpdate".
       * ---
       * TODO: Update this to follow our convention for oneOf, whatever we decide it
       * to be. Same as Deployment `strategy.rollingUpdate`.
       * See https://github.com/kubernetes/kubernetes/issues/35345
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.RollingUpdateDaemonSet rollingUpdate = 2;</code>
       */
      public io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSetOrBuilder getRollingUpdateOrBuilder() {
        if (rollingUpdateBuilder_ != null) {
          return rollingUpdateBuilder_.getMessageOrBuilder();
        } else {
          return rollingUpdate_ == null ?
              io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet.getDefaultInstance() : rollingUpdate_;
        }
      }
      /**
       * <pre>
       * Rolling update config params. Present only if type = "RollingUpdate".
       * ---
       * TODO: Update this to follow our convention for oneOf, whatever we decide it
       * to be. Same as Deployment `strategy.rollingUpdate`.
       * See https://github.com/kubernetes/kubernetes/issues/35345
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.api.apps.v1.RollingUpdateDaemonSet rollingUpdate = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet, io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet.Builder, io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSetOrBuilder> 
          getRollingUpdateFieldBuilder() {
        if (rollingUpdateBuilder_ == null) {
          rollingUpdateBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet, io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet.Builder, io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSetOrBuilder>(
                  getRollingUpdate(),
                  getParentForChildren(),
                  isClean());
          rollingUpdate_ = null;
        }
        return rollingUpdateBuilder_;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.apps.v1.DaemonSetUpdateStrategy)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.apps.v1.DaemonSetUpdateStrategy)
    private static final io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy();
    }

    public static io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<DaemonSetUpdateStrategy>
        PARSER = new com.google.protobuf.AbstractParser<DaemonSetUpdateStrategy>() {
      public DaemonSetUpdateStrategy parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
          return new DaemonSetUpdateStrategy(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<DaemonSetUpdateStrategy> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<DaemonSetUpdateStrategy> getParserForType() {
      return PARSER;
    }

    public io.kubernetes.client.proto.V1Apps.DaemonSetUpdateStrategy getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface RollingUpdateDaemonSetOrBuilder extends
      // @@protoc_insertion_point(interface_extends:k8s.io.api.apps.v1.RollingUpdateDaemonSet)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The maximum number of DaemonSet pods that can be unavailable during the
     * update. Value can be an absolute number (ex: 5) or a percentage of total
     * number of DaemonSet pods at the start of the update (ex: 10%). Absolute
     * number is calculated from percentage by rounding up.
     * This cannot be 0.
     * Default value is 1.
     * Example: when this is set to 30%, at most 30% of the total number of nodes
     * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
     * can have their pods stopped for an update at any given
     * time. The update starts by stopping at most 30% of those DaemonSet pods
     * and then brings up new DaemonSet pods in their place. Once the new pods
     * are available, it then proceeds onto other DaemonSet pods, thus ensuring
     * that at least 70% of original number of DaemonSet pods are available at
     * all times during the update.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
     */
    boolean hasMaxUnavailable();
    /**
     * <pre>
     * The maximum number of DaemonSet pods that can be unavailable during the
     * update. Value can be an absolute number (ex: 5) or a percentage of total
     * number of DaemonSet pods at the start of the update (ex: 10%). Absolute
     * number is calculated from percentage by rounding up.
     * This cannot be 0.
     * Default value is 1.
     * Example: when this is set to 30%, at most 30% of the total number of nodes
     * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
     * can have their pods stopped for an update at any given
     * time. The update starts by stopping at most 30% of those DaemonSet pods
     * and then brings up new DaemonSet pods in their place. Once the new pods
     * are available, it then proceeds onto other DaemonSet pods, thus ensuring
     * that at least 70% of original number of DaemonSet pods are available at
     * all times during the update.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
     */
    io.kubernetes.client.proto.IntStr.IntOrString getMaxUnavailable();
    /**
     * <pre>
     * The maximum number of DaemonSet pods that can be unavailable during the
     * update. Value can be an absolute number (ex: 5) or a percentage of total
     * number of DaemonSet pods at the start of the update (ex: 10%). Absolute
     * number is calculated from percentage by rounding up.
     * This cannot be 0.
     * Default value is 1.
     * Example: when this is set to 30%, at most 30% of the total number of nodes
     * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
     * can have their pods stopped for an update at any given
     * time. The update starts by stopping at most 30% of those DaemonSet pods
     * and then brings up new DaemonSet pods in their place. Once the new pods
     * are available, it then proceeds onto other DaemonSet pods, thus ensuring
     * that at least 70% of original number of DaemonSet pods are available at
     * all times during the update.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
     */
    io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder getMaxUnavailableOrBuilder();
  }
  /**
   * <pre>
   * Spec to control the desired behavior of daemon set rolling update.
   * </pre>
   *
   * Protobuf type {@code k8s.io.api.apps.v1.RollingUpdateDaemonSet}
   */
  public  static final class RollingUpdateDaemonSet extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:k8s.io.api.apps.v1.RollingUpdateDaemonSet)
      RollingUpdateDaemonSetOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use RollingUpdateDaemonSet.newBuilder() to construct.
    private RollingUpdateDaemonSet(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private RollingUpdateDaemonSet() {
    }

    @java.lang.Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private RollingUpdateDaemonSet(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownField(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              io.kubernetes.client.proto.IntStr.IntOrString.Builder subBuilder = null;
              if (((bitField0_ & 0x00000001) == 0x00000001)) {
                subBuilder = maxUnavailable_.toBuilder();
              }
              maxUnavailable_ = input.readMessage(io.kubernetes.client.proto.IntStr.IntOrString.PARSER, extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(maxUnavailable_);
                maxUnavailable_ = subBuilder.buildPartial();
              }
              bitField0_ |= 0x00000001;
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_RollingUpdateDaemonSet_descriptor;
    }

    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_RollingUpdateDaemonSet_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet.class, io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet.Builder.class);
    }

    private int bitField0_;
    public static final int MAXUNAVAILABLE_FIELD_NUMBER = 1;
    private io.kubernetes.client.proto.IntStr.IntOrString maxUnavailable_;
    /**
     * <pre>
     * The maximum number of DaemonSet pods that can be unavailable during the
     * update. Value can be an absolute number (ex: 5) or a percentage of total
     * number of DaemonSet pods at the start of the update (ex: 10%). Absolute
     * number is calculated from percentage by rounding up.
     * This cannot be 0.
     * Default value is 1.
     * Example: when this is set to 30%, at most 30% of the total number of nodes
     * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
     * can have their pods stopped for an update at any given
     * time. The update starts by stopping at most 30% of those DaemonSet pods
     * and then brings up new DaemonSet pods in their place. Once the new pods
     * are available, it then proceeds onto other DaemonSet pods, thus ensuring
     * that at least 70% of original number of DaemonSet pods are available at
     * all times during the update.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
     */
    public boolean hasMaxUnavailable() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }
    /**
     * <pre>
     * The maximum number of DaemonSet pods that can be unavailable during the
     * update. Value can be an absolute number (ex: 5) or a percentage of total
     * number of DaemonSet pods at the start of the update (ex: 10%). Absolute
     * number is calculated from percentage by rounding up.
     * This cannot be 0.
     * Default value is 1.
     * Example: when this is set to 30%, at most 30% of the total number of nodes
     * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
     * can have their pods stopped for an update at any given
     * time. The update starts by stopping at most 30% of those DaemonSet pods
     * and then brings up new DaemonSet pods in their place. Once the new pods
     * are available, it then proceeds onto other DaemonSet pods, thus ensuring
     * that at least 70% of original number of DaemonSet pods are available at
     * all times during the update.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
     */
    public io.kubernetes.client.proto.IntStr.IntOrString getMaxUnavailable() {
      return maxUnavailable_ == null ? io.kubernetes.client.proto.IntStr.IntOrString.getDefaultInstance() : maxUnavailable_;
    }
    /**
     * <pre>
     * The maximum number of DaemonSet pods that can be unavailable during the
     * update. Value can be an absolute number (ex: 5) or a percentage of total
     * number of DaemonSet pods at the start of the update (ex: 10%). Absolute
     * number is calculated from percentage by rounding up.
     * This cannot be 0.
     * Default value is 1.
     * Example: when this is set to 30%, at most 30% of the total number of nodes
     * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
     * can have their pods stopped for an update at any given
     * time. The update starts by stopping at most 30% of those DaemonSet pods
     * and then brings up new DaemonSet pods in their place. Once the new pods
     * are available, it then proceeds onto other DaemonSet pods, thus ensuring
     * that at least 70% of original number of DaemonSet pods are available at
     * all times during the update.
     * +optional
     * </pre>
     *
     * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
     */
    public io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder getMaxUnavailableOrBuilder() {
      return maxUnavailable_ == null ? io.kubernetes.client.proto.IntStr.IntOrString.getDefaultInstance() : maxUnavailable_;
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        output.writeMessage(1, getMaxUnavailable());
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) == 0x00000001)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, getMaxUnavailable());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet)) {
        return super.equals(obj);
      }
      io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet other = (io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet) obj;

      boolean result = true;
      result = result && (hasMaxUnavailable() == other.hasMaxUnavailable());
      if (hasMaxUnavailable()) {
        result = result && getMaxUnavailable()
            .equals(other.getMaxUnavailable());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasMaxUnavailable()) {
        hash = (37 * hash) + MAXUNAVAILABLE_FIELD_NUMBER;
        hash = (53 * hash) + getMaxUnavailable().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Spec to control the desired behavior of daemon set rolling update.
     * </pre>
     *
     * Protobuf type {@code k8s.io.api.apps.v1.RollingUpdateDaemonSet}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:k8s.io.api.apps.v1.RollingUpdateDaemonSet)
        io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSetOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_RollingUpdateDaemonSet_descriptor;
      }

      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_RollingUpdateDaemonSet_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet.class, io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet.Builder.class);
      }

      // Construct using io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getMaxUnavailableFieldBuilder();
        }
      }
      public Builder clear() {
        super.clear();
        if (maxUnavailableBuilder_ == null) {
          maxUnavailable_ = null;
        } else {
          maxUnavailableBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return io.kubernetes.client.proto.V1Apps.internal_static_k8s_io_api_apps_v1_RollingUpdateDaemonSet_descriptor;
      }

      public io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet getDefaultInstanceForType() {
        return io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet.getDefaultInstance();
      }

      public io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet build() {
        io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet buildPartial() {
        io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet result = new io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        if (maxUnavailableBuilder_ == null) {
          result.maxUnavailable_ = maxUnavailable_;
        } else {
          result.maxUnavailable_ = maxUnavailableBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, java.lang.Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          java.lang.Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet) {
          return mergeFrom((io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet other) {
        if (other == io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet.getDefaultInstance()) return this;
        if (other.hasMaxUnavailable()) {
          mergeMaxUnavailable(other.getMaxUnavailable());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private io.kubernetes.client.proto.IntStr.IntOrString maxUnavailable_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.IntStr.IntOrString, io.kubernetes.client.proto.IntStr.IntOrString.Builder, io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder> maxUnavailableBuilder_;
      /**
       * <pre>
       * The maximum number of DaemonSet pods that can be unavailable during the
       * update. Value can be an absolute number (ex: 5) or a percentage of total
       * number of DaemonSet pods at the start of the update (ex: 10%). Absolute
       * number is calculated from percentage by rounding up.
       * This cannot be 0.
       * Default value is 1.
       * Example: when this is set to 30%, at most 30% of the total number of nodes
       * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
       * can have their pods stopped for an update at any given
       * time. The update starts by stopping at most 30% of those DaemonSet pods
       * and then brings up new DaemonSet pods in their place. Once the new pods
       * are available, it then proceeds onto other DaemonSet pods, thus ensuring
       * that at least 70% of original number of DaemonSet pods are available at
       * all times during the update.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
       */
      public boolean hasMaxUnavailable() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <pre>
       * The maximum number of DaemonSet pods that can be unavailable during the
       * update. Value can be an absolute number (ex: 5) or a percentage of total
       * number of DaemonSet pods at the start of the update (ex: 10%). Absolute
       * number is calculated from percentage by rounding up.
       * This cannot be 0.
       * Default value is 1.
       * Example: when this is set to 30%, at most 30% of the total number of nodes
       * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
       * can have their pods stopped for an update at any given
       * time. The update starts by stopping at most 30% of those DaemonSet pods
       * and then brings up new DaemonSet pods in their place. Once the new pods
       * are available, it then proceeds onto other DaemonSet pods, thus ensuring
       * that at least 70% of original number of DaemonSet pods are available at
       * all times during the update.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
       */
      public io.kubernetes.client.proto.IntStr.IntOrString getMaxUnavailable() {
        if (maxUnavailableBuilder_ == null) {
          return maxUnavailable_ == null ? io.kubernetes.client.proto.IntStr.IntOrString.getDefaultInstance() : maxUnavailable_;
        } else {
          return maxUnavailableBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * The maximum number of DaemonSet pods that can be unavailable during the
       * update. Value can be an absolute number (ex: 5) or a percentage of total
       * number of DaemonSet pods at the start of the update (ex: 10%). Absolute
       * number is calculated from percentage by rounding up.
       * This cannot be 0.
       * Default value is 1.
       * Example: when this is set to 30%, at most 30% of the total number of nodes
       * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
       * can have their pods stopped for an update at any given
       * time. The update starts by stopping at most 30% of those DaemonSet pods
       * and then brings up new DaemonSet pods in their place. Once the new pods
       * are available, it then proceeds onto other DaemonSet pods, thus ensuring
       * that at least 70% of original number of DaemonSet pods are available at
       * all times during the update.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
       */
      public Builder setMaxUnavailable(io.kubernetes.client.proto.IntStr.IntOrString value) {
        if (maxUnavailableBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          maxUnavailable_ = value;
          onChanged();
        } else {
          maxUnavailableBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * The maximum number of DaemonSet pods that can be unavailable during the
       * update. Value can be an absolute number (ex: 5) or a percentage of total
       * number of DaemonSet pods at the start of the update (ex: 10%). Absolute
       * number is calculated from percentage by rounding up.
       * This cannot be 0.
       * Default value is 1.
       * Example: when this is set to 30%, at most 30% of the total number of nodes
       * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
       * can have their pods stopped for an update at any given
       * time. The update starts by stopping at most 30% of those DaemonSet pods
       * and then brings up new DaemonSet pods in their place. Once the new pods
       * are available, it then proceeds onto other DaemonSet pods, thus ensuring
       * that at least 70% of original number of DaemonSet pods are available at
       * all times during the update.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
       */
      public Builder setMaxUnavailable(
          io.kubernetes.client.proto.IntStr.IntOrString.Builder builderForValue) {
        if (maxUnavailableBuilder_ == null) {
          maxUnavailable_ = builderForValue.build();
          onChanged();
        } else {
          maxUnavailableBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * The maximum number of DaemonSet pods that can be unavailable during the
       * update. Value can be an absolute number (ex: 5) or a percentage of total
       * number of DaemonSet pods at the start of the update (ex: 10%). Absolute
       * number is calculated from percentage by rounding up.
       * This cannot be 0.
       * Default value is 1.
       * Example: when this is set to 30%, at most 30% of the total number of nodes
       * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
       * can have their pods stopped for an update at any given
       * time. The update starts by stopping at most 30% of those DaemonSet pods
       * and then brings up new DaemonSet pods in their place. Once the new pods
       * are available, it then proceeds onto other DaemonSet pods, thus ensuring
       * that at least 70% of original number of DaemonSet pods are available at
       * all times during the update.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
       */
      public Builder mergeMaxUnavailable(io.kubernetes.client.proto.IntStr.IntOrString value) {
        if (maxUnavailableBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001) &&
              maxUnavailable_ != null &&
              maxUnavailable_ != io.kubernetes.client.proto.IntStr.IntOrString.getDefaultInstance()) {
            maxUnavailable_ =
              io.kubernetes.client.proto.IntStr.IntOrString.newBuilder(maxUnavailable_).mergeFrom(value).buildPartial();
          } else {
            maxUnavailable_ = value;
          }
          onChanged();
        } else {
          maxUnavailableBuilder_.mergeFrom(value);
        }
        bitField0_ |= 0x00000001;
        return this;
      }
      /**
       * <pre>
       * The maximum number of DaemonSet pods that can be unavailable during the
       * update. Value can be an absolute number (ex: 5) or a percentage of total
       * number of DaemonSet pods at the start of the update (ex: 10%). Absolute
       * number is calculated from percentage by rounding up.
       * This cannot be 0.
       * Default value is 1.
       * Example: when this is set to 30%, at most 30% of the total number of nodes
       * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
       * can have their pods stopped for an update at any given
       * time. The update starts by stopping at most 30% of those DaemonSet pods
       * and then brings up new DaemonSet pods in their place. Once the new pods
       * are available, it then proceeds onto other DaemonSet pods, thus ensuring
       * that at least 70% of original number of DaemonSet pods are available at
       * all times during the update.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
       */
      public Builder clearMaxUnavailable() {
        if (maxUnavailableBuilder_ == null) {
          maxUnavailable_ = null;
          onChanged();
        } else {
          maxUnavailableBuilder_.clear();
        }
        bitField0_ = (bitField0_ & ~0x00000001);
        return this;
      }
      /**
       * <pre>
       * The maximum number of DaemonSet pods that can be unavailable during the
       * update. Value can be an absolute number (ex: 5) or a percentage of total
       * number of DaemonSet pods at the start of the update (ex: 10%). Absolute
       * number is calculated from percentage by rounding up.
       * This cannot be 0.
       * Default value is 1.
       * Example: when this is set to 30%, at most 30% of the total number of nodes
       * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
       * can have their pods stopped for an update at any given
       * time. The update starts by stopping at most 30% of those DaemonSet pods
       * and then brings up new DaemonSet pods in their place. Once the new pods
       * are available, it then proceeds onto other DaemonSet pods, thus ensuring
       * that at least 70% of original number of DaemonSet pods are available at
       * all times during the update.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
       */
      public io.kubernetes.client.proto.IntStr.IntOrString.Builder getMaxUnavailableBuilder() {
        bitField0_ |= 0x00000001;
        onChanged();
        return getMaxUnavailableFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * The maximum number of DaemonSet pods that can be unavailable during the
       * update. Value can be an absolute number (ex: 5) or a percentage of total
       * number of DaemonSet pods at the start of the update (ex: 10%). Absolute
       * number is calculated from percentage by rounding up.
       * This cannot be 0.
       * Default value is 1.
       * Example: when this is set to 30%, at most 30% of the total number of nodes
       * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
       * can have their pods stopped for an update at any given
       * time. The update starts by stopping at most 30% of those DaemonSet pods
       * and then brings up new DaemonSet pods in their place. Once the new pods
       * are available, it then proceeds onto other DaemonSet pods, thus ensuring
       * that at least 70% of original number of DaemonSet pods are available at
       * all times during the update.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
       */
      public io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder getMaxUnavailableOrBuilder() {
        if (maxUnavailableBuilder_ != null) {
          return maxUnavailableBuilder_.getMessageOrBuilder();
        } else {
          return maxUnavailable_ == null ?
              io.kubernetes.client.proto.IntStr.IntOrString.getDefaultInstance() : maxUnavailable_;
        }
      }
      /**
       * <pre>
       * The maximum number of DaemonSet pods that can be unavailable during the
       * update. Value can be an absolute number (ex: 5) or a percentage of total
       * number of DaemonSet pods at the start of the update (ex: 10%). Absolute
       * number is calculated from percentage by rounding up.
       * This cannot be 0.
       * Default value is 1.
       * Example: when this is set to 30%, at most 30% of the total number of nodes
       * that should be running the daemon pod (i.e. status.desiredNumberScheduled)
       * can have their pods stopped for an update at any given
       * time. The update starts by stopping at most 30% of those DaemonSet pods
       * and then brings up new DaemonSet pods in their place. Once the new pods
       * are available, it then proceeds onto other DaemonSet pods, thus ensuring
       * that at least 70% of original number of DaemonSet pods are available at
       * all times during the update.
       * +optional
       * </pre>
       *
       * <code>optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString maxUnavailable = 1;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          io.kubernetes.client.proto.IntStr.IntOrString, io.kubernetes.client.proto.IntStr.IntOrString.Builder, io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder> 
          getMaxUnavailableFieldBuilder() {
        if (maxUnavailableBuilder_ == null) {
          maxUnavailableBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              io.kubernetes.client.proto.IntStr.IntOrString, io.kubernetes.client.proto.IntStr.IntOrString.Builder, io.kubernetes.client.proto.IntStr.IntOrStringOrBuilder>(
                  getMaxUnavailable(),
                  getParentForChildren(),
                  isClean());
          maxUnavailable_ = null;
        }
        return maxUnavailableBuilder_;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFields(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:k8s.io.api.apps.v1.RollingUpdateDaemonSet)
    }

    // @@protoc_insertion_point(class_scope:k8s.io.api.apps.v1.RollingUpdateDaemonSet)
    private static final io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet();
    }

    public static io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    @java.lang.Deprecated public static final com.google.protobuf.Parser<RollingUpdateDaemonSet>
        PARSER = new com.google.protobuf.AbstractParser<RollingUpdateDaemonSet>() {
      public RollingUpdateDaemonSet parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
          return new RollingUpdateDaemonSet(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<RollingUpdateDaemonSet> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<RollingUpdateDaemonSet> getParserForType() {
      return PARSER;
    }

    public io.kubernetes.client.proto.V1Apps.RollingUpdateDaemonSet getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_apps_v1_DaemonSet_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_apps_v1_DaemonSet_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_apps_v1_DaemonSetList_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_apps_v1_DaemonSetList_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_apps_v1_DaemonSetSpec_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_apps_v1_DaemonSetSpec_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_apps_v1_DaemonSetStatus_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_apps_v1_DaemonSetStatus_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_apps_v1_DaemonSetUpdateStrategy_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_apps_v1_DaemonSetUpdateStrategy_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_k8s_io_api_apps_v1_RollingUpdateDaemonSet_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_k8s_io_api_apps_v1_RollingUpdateDaemonSet_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static  com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n\"k8s.io/api/apps/v1/generated.proto\022\022k8" +
      "s.io.api.apps.v1\032\"k8s.io/api/core/v1/gen" +
      "erated.proto\032)k8s.io/api/policy/v1beta1/" +
      "generated.proto\0324k8s.io/apimachinery/pkg" +
      "/apis/meta/v1/generated.proto\032/k8s.io/ap" +
      "imachinery/pkg/runtime/generated.proto\0326" +
      "k8s.io/apimachinery/pkg/runtime/schema/g" +
      "enerated.proto\0323k8s.io/apimachinery/pkg/" +
      "util/intstr/generated.proto\"\265\001\n\tDaemonSe" +
      "t\022B\n\010metadata\030\001 \001(\01320.k8s.io.apimachiner",
      "y.pkg.apis.meta.v1.ObjectMeta\022/\n\004spec\030\002 " +
      "\001(\0132!.k8s.io.api.apps.v1.DaemonSetSpec\0223" +
      "\n\006status\030\003 \001(\0132#.k8s.io.api.apps.v1.Daem" +
      "onSetStatus\"\177\n\rDaemonSetList\022@\n\010metadata" +
      "\030\001 \001(\0132..k8s.io.apimachinery.pkg.apis.me" +
      "ta.v1.ListMeta\022,\n\005items\030\002 \003(\0132\035.k8s.io.a" +
      "pi.apps.v1.DaemonSet\"\211\002\n\rDaemonSetSpec\022E" +
      "\n\010selector\030\001 \001(\01323.k8s.io.apimachinery.p" +
      "kg.apis.meta.v1.LabelSelector\0225\n\010templat" +
      "e\030\002 \001(\0132#.k8s.io.api.core.v1.PodTemplate",
      "Spec\022C\n\016updateStrategy\030\003 \001(\0132+.k8s.io.ap" +
      "i.apps.v1.DaemonSetUpdateStrategy\022\027\n\017min" +
      "ReadySeconds\030\004 \001(\005\022\034\n\024revisionHistoryLim" +
      "it\030\006 \001(\005\"\212\002\n\017DaemonSetStatus\022\036\n\026currentN" +
      "umberScheduled\030\001 \001(\005\022\032\n\022numberMisschedul" +
      "ed\030\002 \001(\005\022\036\n\026desiredNumberScheduled\030\003 \001(\005" +
      "\022\023\n\013numberReady\030\004 \001(\005\022\032\n\022observedGenerat" +
      "ion\030\005 \001(\003\022\036\n\026updatedNumberScheduled\030\006 \001(" +
      "\005\022\027\n\017numberAvailable\030\007 \001(\005\022\031\n\021numberUnav" +
      "ailable\030\010 \001(\005\022\026\n\016collisionCount\030\t \001(\005\"j\n",
      "\027DaemonSetUpdateStrategy\022\014\n\004type\030\001 \001(\t\022A" +
      "\n\rrollingUpdate\030\002 \001(\0132*.k8s.io.api.apps." +
      "v1.RollingUpdateDaemonSet\"b\n\026RollingUpda" +
      "teDaemonSet\022H\n\016maxUnavailable\030\001 \001(\01320.k8" +
      "s.io.apimachinery.pkg.util.intstr.IntOrS" +
      "tringB(\n\032io.kubernetes.client.protoB\006V1A" +
      "ppsZ\002v1"
    };
    com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner assigner =
        new com.google.protobuf.Descriptors.FileDescriptor.    InternalDescriptorAssigner() {
          public com.google.protobuf.ExtensionRegistry assignDescriptors(
              com.google.protobuf.Descriptors.FileDescriptor root) {
            descriptor = root;
            return null;
          }
        };
    com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
          io.kubernetes.client.proto.V1.getDescriptor(),
          io.kubernetes.client.proto.V1beta1Policy.getDescriptor(),
          io.kubernetes.client.proto.Meta.getDescriptor(),
          io.kubernetes.client.proto.Runtime.getDescriptor(),
          io.kubernetes.client.proto.RuntimeSchema.getDescriptor(),
          io.kubernetes.client.proto.IntStr.getDescriptor(),
        }, assigner);
    internal_static_k8s_io_api_apps_v1_DaemonSet_descriptor =
      getDescriptor().getMessageTypes().get(0);
    internal_static_k8s_io_api_apps_v1_DaemonSet_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_apps_v1_DaemonSet_descriptor,
        new java.lang.String[] { "Metadata", "Spec", "Status", });
    internal_static_k8s_io_api_apps_v1_DaemonSetList_descriptor =
      getDescriptor().getMessageTypes().get(1);
    internal_static_k8s_io_api_apps_v1_DaemonSetList_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_apps_v1_DaemonSetList_descriptor,
        new java.lang.String[] { "Metadata", "Items", });
    internal_static_k8s_io_api_apps_v1_DaemonSetSpec_descriptor =
      getDescriptor().getMessageTypes().get(2);
    internal_static_k8s_io_api_apps_v1_DaemonSetSpec_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_apps_v1_DaemonSetSpec_descriptor,
        new java.lang.String[] { "Selector", "Template", "UpdateStrategy", "MinReadySeconds", "RevisionHistoryLimit", });
    internal_static_k8s_io_api_apps_v1_DaemonSetStatus_descriptor =
      getDescriptor().getMessageTypes().get(3);
    internal_static_k8s_io_api_apps_v1_DaemonSetStatus_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_apps_v1_DaemonSetStatus_descriptor,
        new java.lang.String[] { "CurrentNumberScheduled", "NumberMisscheduled", "DesiredNumberScheduled", "NumberReady", "ObservedGeneration", "UpdatedNumberScheduled", "NumberAvailable", "NumberUnavailable", "CollisionCount", });
    internal_static_k8s_io_api_apps_v1_DaemonSetUpdateStrategy_descriptor =
      getDescriptor().getMessageTypes().get(4);
    internal_static_k8s_io_api_apps_v1_DaemonSetUpdateStrategy_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_apps_v1_DaemonSetUpdateStrategy_descriptor,
        new java.lang.String[] { "Type", "RollingUpdate", });
    internal_static_k8s_io_api_apps_v1_RollingUpdateDaemonSet_descriptor =
      getDescriptor().getMessageTypes().get(5);
    internal_static_k8s_io_api_apps_v1_RollingUpdateDaemonSet_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_k8s_io_api_apps_v1_RollingUpdateDaemonSet_descriptor,
        new java.lang.String[] { "MaxUnavailable", });
    io.kubernetes.client.proto.V1.getDescriptor();
    io.kubernetes.client.proto.V1beta1Policy.getDescriptor();
    io.kubernetes.client.proto.Meta.getDescriptor();
    io.kubernetes.client.proto.Runtime.getDescriptor();
    io.kubernetes.client.proto.RuntimeSchema.getDescriptor();
    io.kubernetes.client.proto.IntStr.getDescriptor();
  }

  // @@protoc_insertion_point(outer_class_scope)
}
